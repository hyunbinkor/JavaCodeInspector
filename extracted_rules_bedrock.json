{
  "metadata": {
    "extractedAt": "2025-09-30T06:50:30.770Z",
    "totalRules": 42,
    "version": "4.0.0-llm",
    "extractor": "llm-enhanced-parser",
    "llmEnabled": true
  },
  "guidelines": [
    {
      "ruleId": "naming_convention.2_1",
      "title": "서비스 ID 업무코드",
      "category": "naming_convention",
      "checkType": "regex",
      "description": "서비스 ID는 업무코드(3자리) + 업무구분(2자리) + 일련번호(4자리) + 기능분류(1자리) + 세분류 일련번호(1자리)로 총 11자리 구성되어야 한다. 기능분류는 0(선조회), 1(조회), 2(갱신)만 허용되며, 세분류 일련번호는 1-9, A-Z만 사용 가능하다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^[A-Z0-9]{3}[A-Z0-9]{2}[A-Z0-9]{4}[012][1-9A-Z]$",
          "flags": "g",
          "description": "서비스 ID 전체 패턴: 업무코드(3) + 업무구분(2) + 일련번호(4) + 기능분류(1) + 세분류(1)"
        },
        {
          "pattern": "^[A-Z0-9]{3}",
          "flags": "g",
          "description": "업무코드 패턴: 3자리 영숫자"
        },
        {
          "pattern": "^.{3}[A-Z0-9]{2}",
          "flags": "g",
          "description": "업무구분 패턴: 4-5번째 자리 2자리 영숫자"
        },
        {
          "pattern": "^.{5}[A-Z0-9]{4}",
          "flags": "g",
          "description": "일련번호 패턴: 6-9번째 자리 4자리 영숫자"
        },
        {
          "pattern": "^.{9}[012]",
          "flags": "g",
          "description": "기능분류 패턴: 10번째 자리는 0, 1, 2 중 하나"
        },
        {
          "pattern": "^.{10}[1-9A-Z]$",
          "flags": "g",
          "description": "세분류 일련번호 패턴: 11번째 자리는 1-9 또는 A-Z"
        }
      ],
      "customValidator": null,
      "keywords": [
        "서비스",
        "ID",
        "업무코드"
      ],
      "examples": {
        "good": [
          "const serviceId = 'ABC01XXXX01';",
          "const SERVICE_ID = 'DEF02YYYY21';",
          "serviceConfig: { id: 'GHI03ZZZZ0A' }",
          "// 기능분류 예시\n// 0: 선조회 - 'ABC0112340Z'\n// 1: 조회 - 'DEF0256781B'\n// 2: 갱신 - 'GHI0398762C'"
        ],
        "bad": [
          "const serviceId = 'AB01XXXX01'; // 업무코드 2자리 (3자리 필요)",
          "const serviceId = 'ABCD01XXXX01'; // 전체 12자리 (11자리 필요)",
          "const serviceId = 'ABC01XXXX31'; // 기능분류 3 (0,1,2만 허용)",
          "const serviceId = 'ABC01XXXX00'; // 세분류 0 (1-9,A-Z만 허용)",
          "const serviceId = 'abc01xxxx01'; // 소문자 사용 (대문자 필요)"
        ]
      },
      "sectionNumber": "2.1",
      "businessRules": [
        "서비스 ID는 총 11자리로 구성되어야 한다",
        "업무코드는 3자리 영숫자로 구성되어야 한다",
        "업무구분은 2자리 영숫자로 구성되어야 한다",
        "일련번호는 4자리 영숫자로 구성되어야 한다",
        "기능분류는 1자리로 0(선조회), 1(조회), 2(갱신) 중 하나여야 한다",
        "세분류 일련번호는 1자리로 1-9 또는 A-Z 중 하나여야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "VariableDeclarator",
          "Property",
          "Literal"
        ],
        "checkConditions": [
          "서비스 ID로 사용되는 문자열 리터럴 검사",
          "서비스 ID 변수명이나 상수명 검사",
          "설정 파일이나 매핑 객체의 서비스 ID 값 검사"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "naming_convention.2_3_1",
      "title": "JOB ID 업무코드",
      "category": "naming_convention",
      "checkType": "regex_with_validation",
      "description": "JOB ID는 업무코드(3자리) + 주기(1자리) + 배치유형(1자리) + 일련번호(4자리)로 총 9자리 구성되어야 하며, 각 구성요소는 정의된 값만 사용해야 한다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "3 자리",
          "flags": "g"
        },
        {
          "pattern": "1 자리",
          "flags": "g"
        },
        {
          "pattern": "1 자리",
          "flags": "g"
        },
        {
          "pattern": "4 자리",
          "flags": "g"
        },
        {
          "pattern": "^[A-Z]{3}[DWMQHYOA][BSD]\\d{4}$",
          "flags": "g",
          "description": "JOB ID 기본 패턴: 3자리 대문자 + 주기코드 + 배치유형 + 4자리 숫자"
        }
      ],
      "customValidator": null,
      "keywords": [
        "JOB",
        "ID",
        "업무코드",
        "DB"
      ],
      "examples": {
        "good": [
          "IFWDB0001 항목 길이 설명 업무코드 3 업무구분코드 2Level 주기 1 D : Daily W : Weekly M : Monthly Q : Quaterly H : Half Y : Yearly O : Online A : At Any Time( 수시 ) 배치유형 1",
          "Time( 수시 )",
          "SP(stored procedure)",
          "const jobId = 'IFWDB0001';",
          "const batchJob = 'HRMDH0025';"
        ],
        "bad": [
          "const jobId = 'IFW0001';  // 주기코드 누락",
          "const jobId = 'IFWXB0001';  // 잘못된 주기코드",
          "const jobId = 'IFWDX0001';  // 잘못된 배치유형",
          "const jobId = 'IFWDB001';   // 일련번호 자릿수 부족",
          "const jobId = 'ifwdb0001';  // 소문자 사용"
        ]
      },
      "sectionNumber": "2.3.1",
      "businessRules": [
        "JOB ID는 총 9자리로 구성되어야 한다",
        "업무코드는 3자리 업무구분코드 2Level을 사용해야 한다",
        "주기는 D(Daily), W(Weekly), M(Monthly), Q(Quarterly), H(Half), Y(Yearly), O(Online), A(At Any Time) 중 하나여야 한다",
        "배치유형은 B(일반배치), S(SP배치), D(후행) 중 하나여야 한다",
        "일련번호는 4자리 숫자로 구성되어야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "VariableDeclarator",
          "Property",
          "Literal"
        ],
        "checkConditions": [
          "변수명이나 상수값에서 JOB ID 패턴 검사",
          "문자열 리터럴에서 JOB ID 형식 검증"
        ]
      },
      "contextualChecks": [
        {
          "condition": "JOB ID 형식의 문자열이 발견된 경우",
          "expectedBehavior": "9자리 구성과 각 구성요소의 유효성을 검증해야 함",
          "violationMessage": "JOB ID는 업무코드(3자리)+주기(1자리)+배치유형(1자리)+일련번호(4자리) 형식을 따라야 합니다"
        },
        {
          "condition": "배치 관련 변수나 상수 정의 시",
          "expectedBehavior": "정의된 주기코드와 배치유형만 사용해야 함",
          "violationMessage": "주기코드는 D,W,M,Q,H,Y,O,A 중 하나, 배치유형은 B,S,D 중 하나를 사용해야 합니다"
        }
      ]
    },
    {
      "ruleId": "naming_convention.2_3_2",
      "title": "STEP ID 배치 JOB ID(9 자리 ) + STEP 일련번호",
      "category": "naming_convention",
      "checkType": "regex",
      "description": "STEP ID는 배치 JOB ID(9자리)와 STEP 일련번호(2자리)를 결합한 11자리 문자열이어야 합니다. JOB ID는 업무코드(3자리) + 주기(1자리) + 배치유형(1자리) + 일련번호(4자리)로 구성되며, STEP 일련번호는 01~99 범위의 2자리 숫자여야 합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "9 자리",
          "flags": "g"
        },
        {
          "pattern": "2 자리",
          "flags": "g"
        },
        {
          "pattern": "3 자리",
          "flags": "g"
        },
        {
          "pattern": "1 자리",
          "flags": "g"
        },
        {
          "pattern": "1 자리",
          "flags": "g"
        },
        {
          "pattern": "^[A-Z0-9]{3}[A-Z0-9][A-Z0-9][0-9]{4}(0[1-9]|[1-9][0-9])$",
          "flags": "g",
          "description": "STEP ID 전체 패턴: 업무코드(3자리) + 주기(1자리) + 배치유형(1자리) + 일련번호(4자리) + STEP번호(01-99)"
        },
        {
          "pattern": "^[A-Z0-9]{9}$",
          "flags": "g",
          "description": "JOB ID 패턴: 9자리 영숫자"
        },
        {
          "pattern": "^(0[1-9]|[1-9][0-9])$",
          "flags": "g",
          "description": "STEP 일련번호 패턴: 01~99 범위의 2자리 숫자"
        }
      ],
      "customValidator": null,
      "keywords": [
        "STEP",
        "ID",
        "배치",
        "JOB",
        "ID(9",
        "자리",
        "일련번호",
        "DB"
      ],
      "examples": {
        "good": [
          "IFWDB000101 항목 길이 설명 JOB ID 9 업무코드 (3 자리 ) + 주기 (1 자리 ) + 배치유형 (1 자리 ) + 일 련번호 (4 자리 ) STEP 일련번호 2 스텝 일련번호 , 01~99",
          "ID(9 자리 )",
          "const STEP_ID = 'IFWDB000101';",
          "stepId: 'BATCHD123401'",
          "String stepId = \"PAYMA567899\";"
        ],
        "bad": [
          "const STEP_ID = 'IFWDB00010';  // 10자리 (STEP 번호 누락)",
          "stepId: 'IFWDB0001001'  // 12자리 (너무 김)",
          "String stepId = \"IFWDB000100\";  // STEP 번호가 00 (범위 위반)",
          "STEP_ID=ifwdb000101  // 소문자 사용"
        ]
      },
      "sectionNumber": "2.3.2",
      "businessRules": [
        "STEP ID는 총 11자리로 구성되어야 한다",
        "JOB ID는 9자리로 구성되어야 한다 (업무코드 3자리 + 주기 1자리 + 배치유형 1자리 + 일련번호 4자리)",
        "STEP 일련번호는 2자리 숫자로 01~99 범위여야 한다",
        "STEP ID는 JOB ID + STEP 일련번호 형태로 명명되어야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "VariableDeclarator",
          "Property",
          "Literal"
        ],
        "checkConditions": [
          "STEP ID로 사용되는 변수나 상수 식별",
          "문자열 리터럴이 STEP ID 패턴을 따르는지 확인",
          "STEP ID 관련 설정 파일이나 프로퍼티 검사"
        ]
      },
      "contextualChecks": [
        {
          "condition": "STEP ID로 사용되는 식별자나 문자열 리터럴 발견",
          "expectedBehavior": "11자리 문자열이며 JOB ID(9자리) + STEP 일련번호(01-99) 패턴을 따라야 함",
          "violationMessage": "STEP ID는 JOB ID(9자리) + STEP 일련번호(01-99)로 구성된 11자리여야 합니다. 예: IFWDB000101"
        },
        {
          "condition": "JOB ID 부분 검증",
          "expectedBehavior": "업무코드(3자리) + 주기(1자리) + 배치유형(1자리) + 일련번호(4자리)로 구성",
          "violationMessage": "JOB ID는 업무코드(3자리) + 주기(1자리) + 배치유형(1자리) + 일련번호(4자리)로 구성되어야 합니다"
        },
        {
          "condition": "STEP 일련번호 범위 검증",
          "expectedBehavior": "01부터 99까지의 2자리 숫자",
          "violationMessage": "STEP 일련번호는 01~99 범위의 2자리 숫자여야 합니다"
        }
      ]
    },
    {
      "ruleId": "naming_convention.2_4_1",
      "title": "input 파일명 - 배치 step ID",
      "category": "naming_convention",
      "checkType": "regex",
      "description": "배치 step의 input 파일명은 배치 STEP ID(11자리) + 선택적 식별번호(.NN) 형태로 명명해야 합니다. 기본 구조는 'SSSSSSSSSSS' 또는 'SSSSSSSSSSS.NN' 형태이며, 여러 파일이 있을 경우 01~99 범위의 식별번호를 사용합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^[A-Z0-9]{11}(\\.[0-9]{2})?$",
          "flags": "g",
          "description": "배치 STEP ID 11자리 + 선택적 식별번호(.01~.99) 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "input",
        "파일명",
        "배치",
        "step",
        "ID",
        "DB"
      ],
      "examples": {
        "good": [
          "ID( 1 1 )",
          "IFWDB000101",
          "IFWDB000101.01",
          "IFWDB000101.02",
          "D1IFW1234AB"
        ],
        "bad": [
          "IFWDB00010",
          "IFWDB000101.1",
          "IFWDB000101.001",
          "ifwdb000101",
          "IFWDB000101.100"
        ]
      },
      "sectionNumber": "2.4.1",
      "businessRules": [
        "STEP ID는 해당 파일을 사용하는 배치 STEP ID로 명명해야 한다",
        "식별번호는 01~99 범위에서 업무에서 직접 채번해야 한다",
        "대외기관으로의 송수신 파일등은 AS-IS 체계를 따라야 한다",
        "다른 STEP의 output을 input으로 사용할 경우는 원래의 output 파일명을 사용해야 한다",
        "배치 STEP에서 여러 개의 파일을 명명해야 하는 경우 식별번호가 추가되어야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "Literal",
          "VariableDeclarator",
          "Property"
        ],
        "checkConditions": [
          "파일명이 문자열 리터럴로 정의된 경우",
          "변수명에 'input', 'file', 'filename' 등이 포함된 경우",
          "배치 관련 설정 파일이나 프로퍼티에서 파일명을 정의하는 경우"
        ]
      },
      "contextualChecks": [
        {
          "condition": "파일명이 배치 input 파일로 사용되는 경우",
          "expectedBehavior": "11자리 STEP ID와 선택적 2자리 식별번호(.01~.99) 형태여야 함",
          "violationMessage": "배치 input 파일명은 'STEP_ID(11자리)' 또는 'STEP_ID(11자리).식별번호(01~99)' 형태여야 합니다"
        },
        {
          "condition": "동일 STEP에서 여러 input 파일을 사용하는 경우",
          "expectedBehavior": "동일한 STEP ID에 서로 다른 식별번호(.01, .02, ...)를 사용해야 함",
          "violationMessage": "여러 input 파일 사용 시 동일 STEP ID에 순차적인 식별번호를 사용해야 합니다"
        },
        {
          "condition": "대외기관 송수신 파일인 경우",
          "expectedBehavior": "AS-IS 체계를 따라야 하므로 이 규칙에서 제외됨",
          "violationMessage": "대외기관 송수신 파일은 AS-IS 체계를 따라야 합니다"
        }
      ]
    },
    {
      "ruleId": "naming_convention.2_4_2",
      "title": "output 파일명 - 배치 step ID",
      "category": "naming_convention",
      "checkType": "regex",
      "description": "배치 step의 output 파일명은 'STEP_ID[.식별번호].ODATE' 형식을 따라야 합니다. STEP_ID는 11자리, 식별번호는 2자리(01-99, 파일이 여러 개일 경우만), ODATE는 8자리 YYYYMMDD 형식입니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^[A-Z0-9]{11}(\\.[0-9]{2})?\\.[0-9]{8}$",
          "flags": "g",
          "description": "배치 output 파일명 패턴: STEP_ID(11자리) + [.식별번호(2자리)] + .ODATE(8자리)"
        },
        {
          "pattern": "^[A-Z0-9]{11}\\.[0-9]{2}\\.[0-9]{8}$",
          "flags": "g",
          "description": "여러 파일이 있는 경우의 패턴"
        },
        {
          "pattern": "^[A-Z0-9]{11}\\.[0-9]{8}$",
          "flags": "g",
          "description": "단일 파일인 경우의 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "output",
        "파일명",
        "배치",
        "step",
        "ID",
        "DB"
      ],
      "examples": {
        "good": [
          "ID(1 1 )",
          "const outputFile = 'IFWDB000101.20120712';",
          "const outputFile1 = 'IFWDB000101.01.20120712';",
          "const outputFile2 = 'IFWDB000101.02.20120712';",
          "fileName: 'BATCH12345A.99.20231215'"
        ],
        "bad": [
          "const outputFile = 'IFW.20120712';",
          "const outputFile = 'IFWDB000101.1.20120712';",
          "const outputFile = 'IFWDB000101.100.20120712';",
          "const outputFile = 'IFWDB000101.2012712';",
          "fileName: 'batch_output.txt'"
        ]
      },
      "sectionNumber": "2.4.2",
      "businessRules": [
        "output 파일명은 배치 STEP ID로 시작해야 한다",
        "STEP ID는 11자리여야 한다",
        "여러 파일이 있을 경우 식별번호(01-99)를 추가해야 한다",
        "ODATE는 YYYYMMDD 형식(8자리)이어야 한다",
        "대외기관 송수신 파일은 AS-IS 체계를 따른다",
        "식별번호는 업무에서 직접 채번한다"
      ],
      "astHints": {
        "nodeTypes": [
          "Literal",
          "VariableDeclarator",
          "Property"
        ],
        "checkConditions": [
          "파일명이 문자열 리터럴로 정의된 경우",
          "파일명이 변수에 할당된 경우",
          "설정 객체의 속성으로 파일명이 정의된 경우"
        ]
      },
      "contextualChecks": [
        {
          "condition": "배치 작업에서 output 파일명을 정의하는 경우",
          "expectedBehavior": "STEP_ID(11자리) + [.식별번호(2자리)] + .ODATE(8자리) 형식을 따라야 함",
          "violationMessage": "배치 output 파일명이 명명 규칙을 위반했습니다. 형식: STEP_ID(11자리)[.식별번호(2자리)].ODATE(8자리)"
        },
        {
          "condition": "여러 개의 output 파일을 생성하는 경우",
          "expectedBehavior": "식별번호(01-99)를 포함하여 파일을 구분해야 함",
          "violationMessage": "여러 output 파일 생성 시 식별번호(01-99)가 필요합니다"
        },
        {
          "condition": "ODATE 부분을 정의하는 경우",
          "expectedBehavior": "YYYYMMDD 형식의 8자리 숫자여야 함",
          "violationMessage": "ODATE는 YYYYMMDD 형식의 8자리 숫자여야 합니다"
        }
      ]
    },
    {
      "ruleId": "naming_convention.2_4_3",
      "title": "파일 IO spec ID 배치 Step ID",
      "category": "naming_convention",
      "checkType": "regex",
      "description": "배치 파일 I/O Spec ID는 'STEP ID(11자리) + 일련번호(2자리) + _ + I/O구분자' 형식을 따라야 합니다. STEP ID는 11자리 영문자, 일련번호는 2자리 숫자(01, 02...), I/O구분자는 I(Input) 또는 O(Output)입니다. 모든 문자는 대문자로 작성해야 합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "1 자리",
          "flags": "g"
        },
        {
          "pattern": "2 자리",
          "flags": "g"
        },
        {
          "pattern": "^[A-Z]{11}\\d{2}_[IO]$",
          "flags": "g",
          "description": "파일 IO Spec ID 패턴: 11자리 대문자 + 2자리 숫자 + 언더스코어 + I 또는 O"
        }
      ],
      "customValidator": null,
      "keywords": [
        "파일",
        "IO",
        "spec",
        "ID",
        "배치",
        "Step",
        "DB"
      ],
      "examples": {
        "good": [
          "ID(1 1 )",
          "Output(O)",
          "IFWDB00010101_I",
          "IFWDB00010101_O",
          "BATCHSTEP0102_I"
        ],
        "bad": [
          "ifwdb00010101_i",
          "IFWDB000101_I",
          "IFWDB0001011_I",
          "IFWDB00010101_X",
          "IFWDB00010101I"
        ]
      },
      "sectionNumber": "2.4.3",
      "businessRules": [
        "파일 IO SPEC ID는 대문자로 등록해야 한다",
        "같은 파일에 대한 IO SPEC이더라도 input과 output을 구분하여 각각 spec을 등록해야 한다",
        "스텝에서 사용하는 파일이 여러 개 있을 경우 일련번호를 01, 02로 채번해야 한다",
        "STEP ID는 11자리를 사용해야 한다",
        "일련번호는 2자리 숫자를 사용해야 한다",
        "I/O 구분자는 Input(I), Output(O)만 사용해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "VariableDeclarator",
          "Property",
          "Literal"
        ],
        "checkConditions": [
          "변수명이나 속성값이 파일 IO Spec ID 패턴을 따르는지 확인",
          "문자열 리터럴이 해당 패턴 형식인지 검사"
        ]
      },
      "contextualChecks": [
        {
          "condition": "파일 IO Spec ID가 정의되거나 사용되는 경우",
          "expectedBehavior": "11자리 대문자 STEP ID + 2자리 일련번호 + _ + I/O 구분자 형식을 따라야 함",
          "violationMessage": "파일 IO Spec ID는 'SSSSSSSSSSSNN_I/O' 형식(S:대문자 11자리, N:숫자 2자리, I/O:Input/Output 구분자)을 따라야 합니다"
        },
        {
          "condition": "동일한 STEP ID와 일련번호를 가진 Input/Output Spec이 정의되는 경우",
          "expectedBehavior": "각각 별도의 _I, _O 구분자를 가져야 함",
          "violationMessage": "같은 파일에 대해서도 Input과 Output Spec을 구분하여 등록해야 합니다"
        }
      ]
    },
    {
      "ruleId": "naming_convention.2_6",
      "title": "클래스 클래스의 이름은 명사여야 하고 , 첫 문자를 대문자로 한다 중간에 의미 있는 단어가",
      "category": "naming_convention",
      "checkType": "regex_with_validation",
      "description": "클래스명은 Pascal Case 표기법을 사용하며, 명사로 구성되어야 합니다. 메타시스템에 정의된 단어를 사용하고, 클래스 유형에 따라 지정된 접미어(Pbc, Cpbc, Pre, Post, Ebc, Ibc, Const, Cc, Ccpre, Ccpost, Job, Step)를 붙여야 합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^[A-Z][a-z]*([A-Z][a-z]*)*$",
          "flags": "g",
          "description": "Pascal Case 패턴 검사"
        },
        {
          "pattern": "(Pbc|Cpbc|Pre|Post|Ebc|Ibc|Const|Cc|Ccpre|Ccpost|Job|Step)$",
          "flags": "g",
          "description": "클래스 접미어 패턴 검사"
        }
      ],
      "customValidator": null,
      "keywords": [
        "클래스",
        "클래스의",
        "이름은",
        "명사여야",
        "하고",
        "문자를",
        "대문자로",
        "한다",
        "중간에",
        "의미"
      ],
      "examples": {
        "good": [
          "class BrnInfoOfrCpbc { }",
          "class UserDataPbc { }",
          "class OrderProcessPre { }",
          "class PaymentValidationPost { }",
          "class SystemConfigConst { }"
        ],
        "bad": [
          "class brnInfoOfrCpbc { }",
          "class BrnInfoOfr { }",
          "class BRN_INFO_OFR_CPBC { }",
          "class brninfoofrCpbc { }",
          "class BrnInfoOfrService { }"
        ]
      },
      "sectionNumber": "2.6",
      "businessRules": [
        "클래스 이름은 명사여야 한다",
        "첫 문자를 대문자로 한다",
        "중간에 의미 있는 단어가 나올 경우 단어의 첫 문자를 대문자로 한다",
        "나머지 문자들은 소문자로 한다",
        "Pascal Case 표기법을 사용한다",
        "메타시스템에 정의되어 있는 단어를 사용한다",
        "각 클래스 유형에 맞는 접미어를 붙여 사용한다",
        "센터컷 선/후처리 클래스는 센터컷 패키지 내에 위치한다"
      ],
      "astHints": {
        "nodeTypes": [
          "ClassDeclaration"
        ],
        "checkConditions": [
          "클래스명이 Pascal Case를 따르는지 확인",
          "지정된 접미어를 포함하는지 확인",
          "센터컷 관련 클래스의 패키지 위치 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "클래스명이 센터컷 선/후처리 관련(Ccpre, Ccpost)인 경우",
          "expectedBehavior": "센터컷 패키지 내에 위치해야 함",
          "violationMessage": "센터컷 선/후처리 클래스는 센터컷 패키지 내에 위치해야 합니다."
        },
        {
          "condition": "클래스명에 사용된 단어들",
          "expectedBehavior": "메타시스템에 정의된 단어를 사용해야 함",
          "violationMessage": "메타시스템에 정의되지 않은 단어가 사용되었습니다."
        }
      ]
    },
    {
      "ruleId": "naming_convention.2_7",
      "title": "메소드 메소드의 이름은 동사여야 하고 , 첫 문자는 소문자이며 , 동사사전 ( 모델링 )",
      "category": "naming_convention",
      "checkType": "static_analysis",
      "description": "camelCase 패턴 검사 - 첫 문자는 소문자, 이후 문자는 영문자와 숫자만 허용",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "메소드",
        "메소드의",
        "이름은",
        "동사여야",
        "하고",
        "문자는",
        "소문자이며",
        "동사사전",
        "모델링",
        "Exception"
      ],
      "examples": {
        "good": [
          "public LData r",
          "retrieveLastTrstNoGvno(LData gvnoInqTrmsEBI)"
        ],
        "bad": []
      },
      "sectionNumber": "2.7",
      "businessRules": [],
      "astHints": {},
      "contextualChecks": []
    },
    {
      "ruleId": "naming_convention.2_8",
      "title": "로컬변수 변수는 소문자만을 사용 하며 , 변수명명규칙에 따라 단어 또는 복합단어로 사용한다",
      "category": "naming_convention",
      "checkType": "regex_with_validation",
      "description": "로컬변수는 소문자로 시작하며, 타입별 접두사(s, b, bd, l, it, t, i, r)를 사용해야 합니다. 복합단어는 camelCase를 적용하고, 메타 시스템의 표준항목/표준단어 조합으로 작성해야 합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^(s|b|bd|l|it|t|i|r)[A-Z][a-zA-Z0-9]*$",
          "flags": "g",
          "description": "타입 접두사 + camelCase 패턴"
        },
        {
          "pattern": "^[a-z][a-zA-Z0-9]*$",
          "flags": "g",
          "description": "소문자 시작 camelCase 패턴 (일반적인 경우)"
        }
      ],
      "customValidator": null,
      "keywords": [
        "로컬변수",
        "변수는",
        "소문자만을",
        "사용",
        "하며",
        "변수명명규칙에",
        "따라",
        "단어",
        "또는",
        "복합단어로"
      ],
      "examples": {
        "good": [
          "aging = new LData();",
          "LData()",
          "LData tPaging = new LData();",
          "BigDecimal bdAccount;",
          "String sUserName;"
        ],
        "bad": [
          "LData Paging = new LData();",
          "BigDecimal Account;",
          "String UserName;",
          "boolean IsValid;",
          "Long account_number;"
        ]
      },
      "sectionNumber": "2.8",
      "businessRules": [
        "로컬변수는 소문자만을 사용해야 한다",
        "변수명명규칙에 따라 단어 또는 복합단어로 사용해야 한다",
        "클래스생성변수(PBC, EBC 등)도 변수명명규칙을 따라야 한다",
        "복합단어의 경우 Camel Case 표기법을 사용해야 한다",
        "변수는 메타 시스템에 등록된 표준항목 또는 표준단어의 조합으로 작성해야 한다",
        "처음부분에 타입 약어를 붙여야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "VariableDeclarator",
          "LocalVariableDeclaration",
          "Parameter"
        ],
        "checkConditions": [
          "로컬 스코프 내의 변수 선언 확인",
          "변수 타입과 이름의 일치성 검증",
          "클래스 생성 변수(new 키워드 사용) 포함"
        ]
      },
      "contextualChecks": [
        {
          "condition": "로컬변수 선언 시",
          "expectedBehavior": "타입에 맞는 접두사와 camelCase 명명 규칙 적용",
          "violationMessage": "로컬변수는 타입 접두사를 포함한 camelCase 형태로 명명해야 합니다"
        },
        {
          "condition": "클래스 생성 변수 선언 시",
          "expectedBehavior": "일반 로컬변수와 동일한 명명 규칙 적용",
          "violationMessage": "클래스 생성 변수도 로컬변수 명명 규칙을 따라야 합니다"
        },
        {
          "condition": "복합단어 사용 시",
          "expectedBehavior": "Camel Case 표기법 적용",
          "violationMessage": "복합단어는 camelCase 표기법을 사용해야 합니다"
        }
      ]
    },
    {
      "ruleId": "naming_convention.2_9",
      "title": "상수 클래스 상수로 선언된 변수의 이름은 모두 대문자를 사용하고 , 의미 있는 단어가 나올",
      "category": "naming_convention",
      "checkType": "static_analysis",
      "description": "클래스 상수(static final)로 선언된 변수는 모든 문자를 대문자로 작성하고, 의미 있는 단어 사이에는 언더스코어(_)를 사용해야 합니다. 또한 상수는 공통 클래스에서만 사용하며, 일반 업무 클래스에서는 상수 선언을 금지합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$",
          "flags": "g",
          "description": "상수명은 대문자와 숫자로 시작하고, 단어 구분은 언더스코어 사용"
        }
      ],
      "customValidator": null,
      "keywords": [
        "상수",
        "클래스",
        "상수로",
        "선언된",
        "변수의",
        "이름은",
        "모두",
        "대문자를",
        "사용하고",
        "의미"
      ],
      "examples": {
        "good": [
          "MIN_WIDTH = 4;",
          "static final int MIN_WIDTH = 4;",
          "static final String DEFAULT_ENCODING = \"UTF-8\";",
          "static final double PI_VALUE = 3.14159;",
          "public static final int MAX_RETRY_COUNT = 3;"
        ],
        "bad": [
          "static final int minWidth = 4;",
          "static final String defaultEncoding = \"UTF-8\";",
          "static final double piValue = 3.14159;",
          "static final int MAX-WIDTH = 100;",
          "static final String max_width_value = \"100px\";"
        ]
      },
      "sectionNumber": "2.9",
      "businessRules": [
        "클래스 상수(static final) 변수명은 모두 대문자로 작성해야 한다",
        "의미 있는 단어 사이에는 언더스코어(_)를 사용해야 한다",
        "상수는 공통 클래스에서만 사용해야 한다",
        "일반 업무 클래스에서는 상수를 선언하지 않아야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "FieldDeclaration",
          "VariableDeclarator"
        ],
        "checkConditions": [
          "static final 키워드가 모두 포함된 필드인지 확인",
          "변수명이 대문자와 언더스코어 패턴을 따르는지 확인",
          "클래스가 공통 클래스인지 일반 업무 클래스인지 구분",
          "일반 업무 클래스에서 상수 선언이 있는지 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "static final 키워드로 선언된 필드가 존재하는 경우",
          "expectedBehavior": "변수명이 모두 대문자이고 단어 구분에 언더스코어를 사용해야 함",
          "violationMessage": "상수명은 모두 대문자를 사용하고 단어 구분에는 언더스코어(_)를 사용해야 합니다"
        },
        {
          "condition": "일반 업무 클래스에서 static final 필드가 선언된 경우",
          "expectedBehavior": "일반 업무 클래스에서는 상수를 선언하지 않아야 함",
          "violationMessage": "상수는 공통 클래스에서만 사용하며, 일반 업무 클래스에서는 상수를 선언하지 않아야 합니다"
        }
      ]
    },
    {
      "ruleId": "naming_convention.2_10",
      "title": "입력 파라미터 메소드의 입력 파라미터의 이름은 로컬변수 명명규칙과 동일하게 사용한다 . -",
      "category": "naming_convention",
      "checkType": "static_analysis",
      "description": "메소드의 입력 파라미터 이름은 로컬변수 명명규칙과 동일하게 작성해야 합니다. 즉, camelCase를 사용하고 첫 글자는 소문자로 시작해야 합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^[a-z][a-zA-Z0-9]*$",
          "flags": "g",
          "description": "camelCase 형태의 파라미터 이름 패턴 (소문자로 시작, 영문자와 숫자만 허용)"
        }
      ],
      "customValidator": null,
      "keywords": [
        "입력",
        "파라미터",
        "메소드의",
        "파라미터의",
        "이름은",
        "로컬변수",
        "명명규칙과",
        "동일하게",
        "사용한다",
        "Exception"
      ],
      "examples": {
        "good": [
          "public LMultiData r",
          "public void r",
          "public LMultiData retrieveList(LData listInqTrms) throws LException",
          "public void regist(String regIstm) throws LException",
          "public boolean validateUser(String userId, String password)"
        ],
        "bad": [
          "public LMultiData retrieveList(LData ListInqTrms) throws LException",
          "public void regist(String REG_ISTM) throws LException",
          "public boolean validateUser(String user_id, String Password)",
          "public void processData(List<String> data_list, int Max_Count)"
        ]
      },
      "sectionNumber": "2.10",
      "businessRules": [
        "메소드의 입력 파라미터 이름은 로컬변수 명명규칙을 따라야 한다",
        "파라미터 이름은 camelCase 형태로 작성해야 한다",
        "파라미터 이름의 첫 글자는 소문자로 시작해야 한다",
        "파라미터 이름에는 언더스코어(_)나 하이픈(-)을 사용하지 않아야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "MethodDeclaration",
          "Parameter",
          "FormalParameter"
        ],
        "checkConditions": [
          "메소드 선언부에서 파라미터 목록을 추출",
          "각 파라미터의 이름이 camelCase 패턴을 따르는지 검증",
          "파라미터 이름이 소문자로 시작하는지 확인",
          "특수문자나 언더스코어 사용 여부 검사"
        ]
      },
      "contextualChecks": [
        {
          "condition": "메소드 파라미터 이름이 대문자로 시작하는 경우",
          "expectedBehavior": "파라미터 이름의 첫 글자를 소문자로 변경",
          "violationMessage": "메소드 파라미터 이름은 소문자로 시작해야 합니다"
        },
        {
          "condition": "메소드 파라미터 이름에 언더스코어(_)가 포함된 경우",
          "expectedBehavior": "언더스코어를 제거하고 camelCase 형태로 변경",
          "violationMessage": "메소드 파라미터 이름에는 언더스코어를 사용할 수 없습니다"
        },
        {
          "condition": "메소드 파라미터 이름이 모두 대문자인 경우",
          "expectedBehavior": "첫 글자는 소문자로, 나머지는 적절한 camelCase 형태로 변경",
          "violationMessage": "메소드 파라미터 이름은 camelCase 형태로 작성해야 합니다"
        }
      ]
    },
    {
      "ruleId": "naming_convention.2_11",
      "title": "Exception try~catch() 구문에서 catch 문 내에 Exception 에",
      "category": "naming_convention",
      "checkType": "static_analysis",
      "description": "try-catch 구문에서 catch 블록 내의 Exception 변수명은 Exception 타입에 따라 정해진 명명 규칙을 따라야 합니다. LBizException은 'lbe', DevonException은 'de', LInterfaceException은 'lie', LDuplicateException은 'lde'로 명명해야 합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "catch\\s*\\(\\s*(LBizException)\\s+(\\w+)\\s*\\)",
          "flags": "g",
          "description": "LBizException catch 블록에서 변수명 검사"
        },
        {
          "pattern": "catch\\s*\\(\\s*(DevonException)\\s+(\\w+)\\s*\\)",
          "flags": "g",
          "description": "DevonException catch 블록에서 변수명 검사"
        },
        {
          "pattern": "catch\\s*\\(\\s*(LInterfaceException)\\s+(\\w+)\\s*\\)",
          "flags": "g",
          "description": "LInterfaceException catch 블록에서 변수명 검사"
        },
        {
          "pattern": "catch\\s*\\(\\s*(LDuplicateException)\\s+(\\w+)\\s*\\)",
          "flags": "g",
          "description": "LDuplicateException catch 블록에서 변수명 검사"
        }
      ],
      "customValidator": null,
      "keywords": [
        "Exception",
        "try~catch()",
        "구문에서",
        "catch",
        "내에",
        "변수"
      ],
      "examples": {
        "good": [
          "catch()",
          "try {\n    // some code\n} catch (LBizException lbe) {\n    logger.error(\"Business exception\", lbe);\n}",
          "try {\n    // some code\n} catch (DevonException de) {\n    handleDevonException(de);\n}",
          "try {\n    // some code\n} catch (LInterfaceException lie) {\n    processInterfaceError(lie);\n}",
          "try {\n    // some code\n} catch (LDuplicateException lde) {\n    handleDuplicate(lde);\n}"
        ],
        "bad": [
          "try {\n    // some code\n} catch (LBizException ex) {\n    logger.error(\"Business exception\", ex);\n}",
          "try {\n    // some code\n} catch (DevonException devon) {\n    handleDevonException(devon);\n}",
          "try {\n    // some code\n} catch (LInterfaceException e) {\n    processInterfaceError(e);\n}",
          "try {\n    // some code\n} catch (LDuplicateException duplicate) {\n    handleDuplicate(duplicate);\n}"
        ]
      },
      "sectionNumber": "2.11",
      "businessRules": [
        "try-catch 구문의 catch 블록에서 Exception 변수명은 Exception 타입별로 정해진 명명 규칙을 따라야 한다",
        "LBizException의 변수명은 'lbe'를 사용해야 한다",
        "DevonException의 변수명은 'de'를 사용해야 한다",
        "LInterfaceException의 변수명은 'lie'를 사용해야 한다",
        "LDuplicateException의 변수명은 'lde'를 사용해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "CatchClause",
          "TryStatement"
        ],
        "checkConditions": [
          "catch 블록의 parameter 타입이 지정된 Exception 타입인지 확인",
          "Exception 타입에 따른 변수명이 규칙에 맞는지 검사",
          "catch parameter의 identifier name과 Exception type 매칭"
        ]
      },
      "contextualChecks": [
        {
          "condition": "catch 블록에서 LBizException 타입의 변수명이 'lbe'가 아닌 경우",
          "expectedBehavior": "LBizException 변수명은 'lbe'를 사용해야 함",
          "violationMessage": "LBizException의 변수명은 'lbe'를 사용해야 합니다"
        },
        {
          "condition": "catch 블록에서 DevonException 타입의 변수명이 'de'가 아닌 경우",
          "expectedBehavior": "DevonException 변수명은 'de'를 사용해야 함",
          "violationMessage": "DevonException의 변수명은 'de'를 사용해야 합니다"
        },
        {
          "condition": "catch 블록에서 LInterfaceException 타입의 변수명이 'lie'가 아닌 경우",
          "expectedBehavior": "LInterfaceException 변수명은 'lie'를 사용해야 함",
          "violationMessage": "LInterfaceException의 변수명은 'lie'를 사용해야 합니다"
        },
        {
          "condition": "catch 블록에서 LDuplicateException 타입의 변수명이 'lde'가 아닌 경우",
          "expectedBehavior": "LDuplicateException 변수명은 'lde'를 사용해야 함",
          "violationMessage": "LDuplicateException의 변수명은 'lde'를 사용해야 합니다"
        }
      ]
    },
    {
      "ruleId": "naming_convention.2_12",
      "title": "LData / LMultiData DB 의 테이블과 연관있는 LData/LMultiData",
      "category": "naming_convention",
      "checkType": "llm_contextual",
      "description": "LData/LMultiData가 DB 테이블과 연관될 때, Key 값은 반드시 해당 DB 컬럼명을 소문자로 변환한 형태로 저장해야 합니다. 이는 SELECT 쿼리 결과를 저장하는 LMultiData와 쿼리 입력으로 전달되는 LData 모두에 적용됩니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "LData|LMultiData",
          "flags": "g",
          "description": "LData 또는 LMultiData 클래스 사용 패턴"
        },
        {
          "pattern": "\\.put\\s*\\(\\s*[\"']([A-Z_]+)[\"']",
          "flags": "g",
          "description": "대문자나 언더스코어가 포함된 Key 사용 패턴 (위반 가능성)"
        },
        {
          "pattern": "\\.get\\s*\\(\\s*[\"']([A-Z_]+)[\"']",
          "flags": "g",
          "description": "대문자나 언더스코어가 포함된 Key 조회 패턴 (위반 가능성)"
        }
      ],
      "customValidator": null,
      "keywords": [
        "LData",
        "LMultiData",
        "DB",
        "테이블과",
        "연관있는",
        "ResultSet",
        "column"
      ],
      "examples": {
        "good": [
          "ldata.put(\"reg_date\", regDate); // DB 컬럼 REG_DATE를 소문자로 변환",
          "lmultiData.put(\"user_id\", userId); // DB 컬럼 USER_ID를 소문자로 변환",
          "String regDate = ldata.get(\"reg_date\"); // 소문자 Key 사용",
          "ldata.put(\"customer_name\", name); // DB 컬럼 CUSTOMER_NAME을 소문자로 변환"
        ],
        "bad": [
          "ldata.put(\"REG_DATE\", regDate); // DB 컬럼명을 대문자 그대로 사용",
          "lmultiData.put(\"USER_ID\", userId); // 대문자 Key 사용",
          "String regDate = ldata.get(\"RegDate\"); // 카멜케이스 사용",
          "ldata.put(\"CUSTOMER_NAME\", name); // 대문자 언더스코어 사용"
        ]
      },
      "sectionNumber": "2.12",
      "businessRules": [
        "SELECT 쿼리 결과 ResultSet을 저장하는 LMultiData의 Key는 해당 DB column명을 소문자로 변환하여 저장해야 한다",
        "쿼리의 입력으로 전달되는 LData는 Key 값을 DB 컬럼명을 소문자로 변환하여 저장해야 한다",
        "DB 컬럼명이 대문자나 언더스코어를 포함하는 경우, 전체를 소문자로 변환해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "MethodCallExpression",
          "VariableDeclarator",
          "AssignmentExpression"
        ],
        "checkConditions": [
          "LData 또는 LMultiData 객체의 put/get 메서드 호출 확인",
          "Key 값이 문자열 리터럴인지 확인",
          "Key 값이 DB 컬럼명 규칙(소문자 + 언더스코어)을 따르는지 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "LData 또는 LMultiData 객체에서 put() 메서드로 데이터를 저장할 때",
          "expectedBehavior": "Key 값은 DB 컬럼명을 소문자로 변환한 형태(예: REG_DATE → reg_date)여야 함",
          "violationMessage": "LData/LMultiData의 Key는 DB 컬럼명을 소문자로 변환하여 사용해야 합니다. (예: REG_DATE → reg_date)"
        },
        {
          "condition": "LData 또는 LMultiData 객체에서 get() 메서드로 데이터를 조회할 때",
          "expectedBehavior": "Key 값은 DB 컬럼명을 소문자로 변환한 형태여야 함",
          "violationMessage": "LData/LMultiData에서 데이터 조회 시 Key는 소문자 형태의 DB 컬럼명을 사용해야 합니다."
        },
        {
          "condition": "SELECT 쿼리 결과를 LMultiData에 저장하는 코드에서",
          "expectedBehavior": "ResultSet의 컬럼명을 소문자로 변환하여 Key로 사용해야 함",
          "violationMessage": "SELECT 쿼리 결과를 LMultiData에 저장할 때는 DB 컬럼명을 소문자로 변환한 Key를 사용해야 합니다."
        },
        {
          "condition": "쿼리 입력 파라미터로 LData를 사용하는 코드에서",
          "expectedBehavior": "LData의 Key는 해당 DB 컬럼명을 소문자로 변환한 형태여야 함",
          "violationMessage": "쿼리 입력용 LData의 Key는 DB 컬럼명을 소문자로 변환하여 사용해야 합니다."
        }
      ]
    },
    {
      "ruleId": "code_style.3_1_1",
      "title": "소스파일 Java 소스파일은 크게 아래와 같은 구조로 되어 있다 ▪ 파일 주석",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "Java 소스파일은 정해진 구조적 순서를 따라야 합니다: 1) 파일 주석(Beginning Comments), 2) 패키지 선언문, 3) import 문, 4) 클래스나 인터페이스 설명 주석, 5) 클래스나 인터페이스 정의. 각 요소는 이 순서대로 배치되어야 하며, 필수 요소(패키지 선언문, 클래스/인터페이스 정의)는 반드시 포함되어야 합니다.",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "소스파일",
        "Java",
        "소스파일은",
        "크게",
        "아래와",
        "같은",
        "구조로",
        "되어",
        "있다",
        "파일"
      ],
      "examples": {
        "good": [
          "/*\n * File: Example.java\n * Description: This is a sample file\n */\npackage com.example;\n\nimport java.util.List;\nimport java.util.ArrayList;\n\n/**\n * Example class description\n */\npublic class Example {\n    // class implementation\n}",
          "/*\n * Beginning comment\n */\npackage com.test;\n\nimport java.io.*;\n\n/**\n * Interface documentation\n */\npublic interface TestInterface {\n    void method();\n}"
        ],
        "bad": [
          "package com.example;\n/*\n * File comment in wrong position\n */\nimport java.util.List;\n\npublic class Example {\n    // class implementation\n}",
          "import java.util.List;\npackage com.example;\n\n/**\n * Class description\n */\npublic class Example {\n    // class implementation\n}",
          "package com.example;\nimport java.util.List;\npublic class Example {\n    // class implementation without proper structure\n}"
        ]
      },
      "sectionNumber": "3.1.1",
      "businessRules": [
        "Java 소스파일은 파일 주석, 패키지 선언문, import 문, 클래스/인터페이스 설명 주석, 클래스/인터페이스 정의 순서로 구성되어야 한다",
        "패키지 선언문은 파일 주석 다음에 위치해야 한다",
        "import 문은 패키지 선언문 다음에 위치해야 한다",
        "클래스나 인터페이스 정의는 파일의 마지막에 위치해야 한다",
        "클래스나 인터페이스 설명 주석은 해당 정의 바로 앞에 위치해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "CompilationUnit",
          "PackageDeclaration",
          "ImportDeclaration",
          "ClassDeclaration",
          "InterfaceDeclaration",
          "Comment"
        ],
        "checkConditions": [
          "CompilationUnit의 자식 노드들이 올바른 순서로 배치되어 있는지 확인",
          "PackageDeclaration이 ImportDeclaration보다 앞에 위치하는지 확인",
          "ImportDeclaration이 ClassDeclaration/InterfaceDeclaration보다 앞에 위치하는지 확인",
          "파일 시작 부분의 주석(Beginning Comments) 존재 여부 확인",
          "클래스/인터페이스 정의 직전의 Javadoc 주석 존재 여부 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_1_2",
      "title": "줄 나누기 한 행에 모두 기술하지 못할 경우 행을 나누는 규칙은 다음과 같다 1) 콤마",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "한 행에 모두 기술하지 못할 경우 줄 나누기 규칙을 준수해야 합니다. 1) 콤마(,) 뒤에서 나누기, 2) 연산자 앞에서 나누기, 3) 높은 단계에서 나누기, 4) 같은 단계의 나누어진 줄은 위 줄과 같은 컬럼에 정렬하기. 메서드 파라미터가 많을 경우 한 줄에 하나씩 기입하고, 긴 문자열 연결은 StringBuffer를 사용하며, 복잡한 조건문은 적절히 나누어 여러 줄로 작성해야 합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": ",\\s*\\n",
          "flags": "g",
          "description": "콤마 뒤 줄바꿈 패턴"
        },
        {
          "pattern": "\\n\\s*[+\\-*/&|<>=!]+",
          "flags": "g",
          "description": "연산자 앞 줄바꿈 패턴"
        },
        {
          "pattern": "\"[^\"]*\"\\s*\\+\\s*\"[^\"]*\"",
          "flags": "g",
          "description": "문자열 + 연산자 연결 패턴 (금지)"
        }
      ],
      "customValidator": null,
      "keywords": [
        "나누기",
        "행에",
        "모두",
        "기술하지",
        "못할",
        "경우",
        "행을",
        "나누는",
        "규칙은",
        "다음과"
      ],
      "examples": {
        "good": [
          "sql1 = new StringBuffer( “SELECT COLUMN1, COLUMN2, COLUMN3, COLUMN4” );",
          "COLUMN1 = ‘ ” + VALUE1 + “’” );",
          "public DamageInfo g",
          "StringBuffer( “SELECT COLUMN1, COLUMN2, COLUMN3, COLUMN4” )",
          "append( “FROM TABLE1, TABLE2, TABLE3” )"
        ],
        "bad": [
          "public DamageInfo getDamageDetail(String pDisasterMgmtNo, String pOccurAddrCode, String pDmgCauseCode, Connection pConn) throws SQLException, InformException {",
          "String sql = \"SELECT COLUMN1, COLUMN2\" + \"FROM TABLE1\" + \"WHERE COLUMN1 = '\" + VALUE1 + \"'\";",
          "if ((condition1 && condition2) || (condition3 && condition4) || !(condition5 && condition6)) { doSomethingAboutIt(); }"
        ]
      },
      "sectionNumber": "3.1.2",
      "businessRules": [
        "콤마(,) 뒤에서 줄을 나누어야 한다",
        "연산자 앞에서 줄을 나누어야 한다",
        "높은 단계에서 줄을 나누어야 한다",
        "나누어진 줄이 같은 단계라면 위의 줄과 같은 컬럼에 위치시켜야 한다",
        "메서드 파라미터가 많을 경우 한 줄에 하나씩 여러 줄에 기입해야 한다",
        "긴 문자열 연결은 StringBuffer 클래스를 이용해야 한다",
        "긴 문자열 연결 시 연결연산자(+)를 사용하지 않아야 한다",
        "복잡한 조건문은 적당한 조건단위로 나누어 여러 줄에 사용해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "MethodDeclaration",
          "NewExpression",
          "BinaryExpression",
          "IfStatement",
          "CallExpression"
        ],
        "checkConditions": [
          "메서드 파라미터가 3개 이상일 때 각 파라미터가 별도 줄에 있는지 확인",
          "StringBuffer 사용 여부 확인 (긴 문자열 연결 시)",
          "복잡한 조건문의 적절한 줄바꿈 확인",
          "같은 레벨의 코드 블록 들여쓰기 일관성 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "메서드 파라미터가 3개 이상인 경우",
          "expectedBehavior": "각 파라미터를 별도 줄에 작성하고 적절히 들여쓰기",
          "violationMessage": "메서드 파라미터가 많을 경우 한 줄에 하나씩 여러 줄에 기입해야 합니다"
        },
        {
          "condition": "긴 문자열을 연결하는 경우",
          "expectedBehavior": "StringBuffer 클래스를 사용하여 append 메서드로 연결",
          "violationMessage": "긴 문자열 연결은 StringBuffer 클래스를 이용하고 + 연산자 사용을 피해야 합니다"
        },
        {
          "condition": "복잡한 조건문 (3개 이상의 조건 조합)",
          "expectedBehavior": "적절한 조건 단위로 나누어 여러 줄에 작성하고 들여쓰기 적용",
          "violationMessage": "복잡한 조건문은 적당한 조건단위로 나누어 여러 줄에 사용해야 합니다"
        }
      ]
    },
    {
      "ruleId": "documentation.3_2_1",
      "title": "공통 1) 모든 소스는 Java API Documentation 생성에 부합하도록 주석문을",
      "category": "documentation",
      "checkType": "static_analysis",
      "description": "Java 소스 코드의 모든 클래스, 메서드, 필드에 대해 Javadoc 표준에 부합하는 주석을 작성해야 합니다. API 문서화용 주석은 /** */ 형식을, 일반 주석은 /* */ 형식을 사용하며, 주석의 들여쓰기는 대상 코드와 일치해야 합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "/\\*\\*\\s*\\*/",
          "flags": "g",
          "description": "빈 Javadoc 주석 검출"
        },
        {
          "pattern": "/\\*\\*[^\\n]*\\S[^\\n]*\\*/",
          "flags": "g",
          "description": "한 줄에 주석 기호와 내용이 함께 있는 잘못된 형식"
        },
        {
          "pattern": "//#GeneralCodeBlock#\\s+[^\\n]+",
          "flags": "g",
          "description": "MDA 자동 생성 주석 형식"
        }
      ],
      "customValidator": null,
      "keywords": [
        "공통",
        "1)",
        "모든",
        "소스는",
        "Java",
        "API",
        "Documentation",
        "생성에",
        "부합하도록",
        "주석문을"
      ],
      "examples": {
        "good": [
          "//#GeneralCodeBlock# 일자정보조회입력 셋팅 //#GeneralCodeBlock# 일자정보조회입력 셋팅 iDtInfoOfr.setString(\"base_dt\", sTxDt);",
          "public class L",
          "private HttpServletRequest r",
          "setString(\"base_dt\", sTxDt)",
          "/**\n * Class constructor specifying number of objects to create.\n */\npublic class LMultipartRequest {\n}"
        ],
        "bad": [
          "/** Class constructor */ public class BadClass {}",
          "/**\n*/\npublic void emptyJavadoc() {}",
          "public class NoComment {\n}",
          "    /**\n* 잘못된 들여쓰기\n    */\n  public void method() {}",
          "/** 한줄주석 */\npublic void badFormat() {}"
        ]
      },
      "sectionNumber": "3.2.1",
      "businessRules": [
        "모든 소스는 Java API Documentation 생성에 부합하도록 주석문을 작성해야 한다",
        "여러 줄 주석에는 /** */ 또는 /* */ 형식을 사용해야 한다",
        "Java API Documentation과 관련된 주석은 /** */ 형식을 사용해야 한다",
        "일반 주석은 /* */ 형식을 사용해야 한다",
        "주석 기호와 내용을 같은 줄에 쓰지 않아야 한다",
        "주석문의 들여쓰기는 주석문 대상의 들여쓰기에 맞춰야 한다",
        "MDA 자동 생성 소스의 주석은 //#GeneralCodeBlock# 형식으로 표시해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "ClassDeclaration",
          "MethodDeclaration",
          "FieldDeclaration",
          "ConstructorDeclaration"
        ],
        "checkConditions": [
          "public 클래스는 Javadoc 주석(/** */)이 있어야 함",
          "public 메서드는 Javadoc 주석이 있어야 함",
          "주석의 들여쓰기가 대상 코드와 일치해야 함",
          "Javadoc 주석은 /** 로 시작하고 */ 로 끝나야 함",
          "주석 내용이 기호와 같은 줄에 있으면 안됨"
        ]
      },
      "contextualChecks": [
        {
          "condition": "public 클래스, 메서드, 필드가 Javadoc 주석 없이 선언된 경우",
          "expectedBehavior": "/** */ 형식의 Javadoc 주석이 있어야 함",
          "violationMessage": "Public 멤버는 Javadoc 주석(/** */)이 필요합니다"
        },
        {
          "condition": "주석의 들여쓰기가 대상 코드와 다른 경우",
          "expectedBehavior": "주석과 대상 코드의 들여쓰기 레벨이 동일해야 함",
          "violationMessage": "주석의 들여쓰기가 대상 코드와 일치하지 않습니다"
        },
        {
          "condition": "/** */ 주석에서 기호와 내용이 같은 줄에 있는 경우",
          "expectedBehavior": "주석 기호와 내용은 별도 줄에 작성되어야 함",
          "violationMessage": "주석 기호와 내용을 같은 줄에 작성하지 마세요"
        }
      ]
    },
    {
      "ruleId": "documentation.3_2_2",
      "title": "I mport 1) import 문은 package 문 바로 밑에 위치 하도록 하며 만약",
      "category": "documentation",
      "checkType": "static_analysis",
      "description": "import 문의 위치, 그룹화, 와일드카드 사용에 대한 규칙을 검사합니다. import 문은 package 문 바로 다음에 위치해야 하며, Java API, 프레임워크 API, 사용자 작성 API 순서로 그룹화하고, 와일드카드(*) 사용을 피해야 합니다.",
      "severity": "MEDIUM",
      "patterns": [
        {
          "pattern": "^import\\s+[a-zA-Z_][a-zA-Z0-9_.]*\\.\\*\\s*;",
          "flags": "gm",
          "description": "와일드카드 import 패턴 검출"
        },
        {
          "pattern": "^import\\s+java\\.[a-zA-Z0-9_.]+;",
          "flags": "gm",
          "description": "Java 표준 라이브러리 import 패턴"
        },
        {
          "pattern": "^package\\s+[a-zA-Z_][a-zA-Z0-9_.]*\\s*;",
          "flags": "gm",
          "description": "package 선언 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "mport",
        "1)",
        "import",
        "문은",
        "package",
        "바로",
        "밑에",
        "위치",
        "하도록",
        "하며"
      ],
      "examples": {
        "good": [
          "package com.example;\n\nimport java.io.File;\nimport java.util.Vector;\n\nimport laf.core.config.LConfiguration;\nimport laf.core.message.LMessage;\n\nimport myutil.Text;\nimport mycom.common.Math;\n\npublic class Example {}",
          "import java.io.File;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport com.mycompany.util.StringUtils;\n\npublic class NoPackageExample {}"
        ],
        "bad": [
          "import java.util.*;\nimport java.io.*;\n\npackage com.example;\n\npublic class BadOrder {}",
          "package com.example;\nimport java.util.*;\nimport java.io.File;\n\npublic class WildcardImport {}",
          "package com.example;\nimport myutil.Text;\nimport java.io.File;\nimport laf.core.config.LConfiguration;\n\npublic class WrongOrder {}"
        ]
      },
      "sectionNumber": "3.2.2",
      "businessRules": [
        "import 문은 package 문 바로 밑에 위치해야 한다",
        "package 문이 없으면 import 문은 파일 최상단에 위치해야 한다",
        "import 문은 성격에 따라 빈 라인으로 구분할 수 있다",
        "import 순서는 Java 제공 API, 프레임워크 제공 API, 사용자 작성 API 순서를 따른다",
        "와일드카드(*) 형태의 import 사용을 피해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "ImportDeclaration",
          "PackageDeclaration",
          "CompilationUnit"
        ],
        "checkConditions": [
          "import 문이 package 문 바로 다음에 위치하는지 확인",
          "import 문들이 올바른 순서로 정렬되어 있는지 확인",
          "와일드카드 import 사용 여부 확인",
          "import 그룹 간 빈 라인 구분 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "import 문의 위치가 package 문 바로 다음이 아닌 경우",
          "expectedBehavior": "import 문은 package 문 바로 다음에 위치해야 함",
          "violationMessage": "import 문은 package 문 바로 밑에 위치해야 합니다"
        },
        {
          "condition": "와일드카드(*) import 사용",
          "expectedBehavior": "구체적인 클래스명을 명시한 import 사용",
          "violationMessage": "의존성 관계를 명확히 하기 위해 와일드카드(*) import 사용을 피해야 합니다"
        },
        {
          "condition": "import 순서가 Java API → 프레임워크 API → 사용자 API 순서가 아닌 경우",
          "expectedBehavior": "Java 제공 API, 프레임워크 제공 API, 사용자 작성 API 순서로 정렬",
          "violationMessage": "import 문은 Java API, 프레임워크 API, 사용자 API 순서로 정렬되어야 합니다"
        }
      ]
    },
    {
      "ruleId": "documentation.3_2_3",
      "title": "클래스 1) Class 나 Interface 선언 전에 기술한다 . 2) 설명 주석 형식은",
      "category": "documentation",
      "checkType": "static_analysis",
      "description": "클래스와 인터페이스는 선언 전에 문서용 주석(/** */)을 작성해야 하며, 주석 내부에는 <PRE> 태그로 기능 설명, @logicalName으로 컴포넌트명, @version으로 버전 정보를 포함해야 합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "/\\*\\*[\\s\\S]*?\\*/\\s*(public|private|protected)?\\s*(class|interface)\\s+\\w+",
          "flags": "g",
          "description": "클래스/인터페이스 선언 전 문서용 주석 존재 확인"
        },
        {
          "pattern": "\\*\\s*<PRE>[\\s\\S]*?</PRE>",
          "flags": "gi",
          "description": "PRE 태그 내 기능 설명 존재 확인"
        },
        {
          "pattern": "\\*\\s*@logicalName\\s+[^\\n]+",
          "flags": "g",
          "description": "logicalName 태그 존재 확인"
        },
        {
          "pattern": "\\*\\s*@version\\s+\\d+\\.\\d+,\\s*\\d{4}/\\d{2}/\\d{2}",
          "flags": "g",
          "description": "version 태그 형식 확인 (버전.번호, YYYY/MM/DD)"
        }
      ],
      "customValidator": null,
      "keywords": [
        "클래스",
        "1)",
        "Class",
        "Interface",
        "선언",
        "전에",
        "기술한다",
        "2)",
        "설명",
        "주석"
      ],
      "examples": {
        "good": [
          "/**\n * <PRE>\n * 고객의 요청에 의한 해당계좌의 서명계좌여부, 안전서비스통장여부를\n * 조회하고 변경 처리한다.\n * </PRE>\n *\n * @logicalName I계좌정보등록Pbc\n * @version 1.0, 2012/01/01\n */\npublic class AccountInfoService {",
          "/**\n * <PRE>\n * 사용자 인증 및 권한 관리를 담당하는 인터페이스\n * </PRE>\n *\n * @logicalName I사용자인증Pbc\n * @version 2.1, 2023/03/15\n */\npublic interface AuthenticationService {"
        ],
        "bad": [
          "// 단순 주석\npublic class AccountInfoService {",
          "/* 블록 주석이지만 문서용이 아님 */\npublic class AccountInfoService {",
          "/**\n * PRE 태그 없는 주석\n * @version 1.0, 2012/01/01\n */\npublic class AccountInfoService {",
          "/**\n * <PRE>\n * 기능 설명만 있고 필수 태그 누락\n * </PRE>\n */\npublic class AccountInfoService {",
          "/**\n * <PRE>\n * 기능 설명\n * </PRE>\n * @logicalName I계좌정보등록Pbc\n * @version 1.0\n */\npublic class AccountInfoService {"
        ]
      },
      "sectionNumber": "3.2.3",
      "businessRules": [
        "Class나 Interface 선언 전에 문서용 주석을 기술해야 한다",
        "설명 주석 형식은 문서용 주석 '/** ... */'을 사용해야 한다",
        "설명 주석 안의 각 라인은 '*'로 시작해야 한다",
        "<PRE> 태그 안에 해당 클래스에 대한 기능과 용도를 기술해야 한다",
        "모델의 컴포넌트명을 이용하여 @logicalName을 기술해야 한다",
        "버전명을 날짜와 함께 @version 형식으로 기술해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "ClassDeclaration",
          "InterfaceDeclaration"
        ],
        "checkConditions": [
          "클래스/인터페이스 노드 직전에 BlockComment 노드가 존재하는지 확인",
          "BlockComment가 /** 로 시작하는지 확인",
          "주석 내용에 <PRE> 태그, @logicalName, @version이 포함되어 있는지 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "클래스나 인터페이스 선언 전에 문서용 주석이 존재하는가",
          "expectedBehavior": "/** */ 형태의 문서용 주석이 클래스/인터페이스 선언 직전에 위치해야 함",
          "violationMessage": "클래스/인터페이스 선언 전에 문서용 주석(/** */)이 필요합니다"
        },
        {
          "condition": "주석 내부에 <PRE> 태그로 감싸진 기능 설명이 있는가",
          "expectedBehavior": "<PRE> 태그 안에 클래스의 기능과 용도가 기술되어야 함",
          "violationMessage": "<PRE> 태그 안에 클래스의 기능과 용도를 기술해야 합니다"
        },
        {
          "condition": "@logicalName 태그가 존재하고 컴포넌트명이 기술되어 있는가",
          "expectedBehavior": "@logicalName 다음에 모델의 컴포넌트명이 기술되어야 함",
          "violationMessage": "@logicalName 태그로 컴포넌트명을 기술해야 합니다"
        },
        {
          "condition": "@version 태그가 올바른 형식(버전, 날짜)으로 기술되어 있는가",
          "expectedBehavior": "@version 다음에 '버전번호, YYYY/MM/DD' 형식으로 기술되어야 함",
          "violationMessage": "@version 태그를 '버전번호, YYYY/MM/DD' 형식으로 기술해야 합니다"
        }
      ]
    },
    {
      "ruleId": "documentation.3_2_4",
      "title": "멤버 변수 1) 멤버 변수 상단에 위치한다 . 2) 주석 형식은 문서용 주석",
      "category": "documentation",
      "checkType": "static_analysis",
      "description": "멤버 변수는 클래스 상단에 위치해야 하며, 문서용 주석(/** ... */)을 사용하여 용도와 제한사항을 기술해야 한다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "/\\*\\*[\\s\\S]*?\\*/\\s*(?:public|private|protected)?\\s*(?:static)?\\s*(?:final)?\\s*\\w+\\s+\\w+\\s*;",
          "flags": "g",
          "description": "문서용 주석이 있는 멤버 변수 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "멤버",
        "변수",
        "1)",
        "상단에",
        "위치한다",
        "2)",
        "주석",
        "형식은",
        "문서용"
      ],
      "examples": {
        "good": [
          "protected Connection c",
          "/**\n * Connection 객체를 가리키는 참조변수.\n */\nprotected Connection conn;",
          "/**\n * 사용자 ID를 저장하는 변수. null일 수 없음.\n */\nprivate String userId;",
          "/**\n * 최대 연결 수. 기본값은 10.\n */\npublic static final int MAX_CONNECTIONS = 10;"
        ],
        "bad": [
          "// Connection 객체\nprotected Connection conn;",
          "protected Connection conn; // 연결 객체",
          "public void method() {}\n/**\n * Connection 객체\n */\nprotected Connection conn;",
          "protected Connection conn;"
        ]
      },
      "sectionNumber": "3.2.4",
      "businessRules": [
        "멤버 변수는 클래스 상단에 위치해야 한다",
        "멤버 변수 주석은 문서용 주석(/** ... */) 형식을 사용해야 한다",
        "멤버 변수 주석에는 용도와 제한사항을 기술해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "FieldDeclaration",
          "VariableDeclarator",
          "BlockComment"
        ],
        "checkConditions": [
          "멤버 변수가 클래스의 첫 번째 멤버들로 위치하는지 확인",
          "멤버 변수 직전에 /** */ 형태의 문서용 주석이 있는지 확인",
          "주석 내용이 용도나 제한사항을 포함하는지 확인",
          "메서드나 생성자보다 멤버 변수가 먼저 선언되는지 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "멤버 변수가 메서드나 생성자 이후에 선언된 경우",
          "expectedBehavior": "멤버 변수는 클래스 상단(메서드나 생성자보다 앞)에 위치해야 함",
          "violationMessage": "멤버 변수는 클래스 상단에 위치해야 합니다"
        },
        {
          "condition": "멤버 변수에 문서용 주석(/** */)이 없는 경우",
          "expectedBehavior": "멤버 변수 직전에 /** */ 형태의 문서용 주석이 있어야 함",
          "violationMessage": "멤버 변수에는 문서용 주석(/** */)을 사용해야 합니다"
        },
        {
          "condition": "멤버 변수 주석이 단순한 설명만 있고 용도나 제한사항이 없는 경우",
          "expectedBehavior": "주석에는 변수의 용도, 제한사항, 기본값 등의 상세 정보가 포함되어야 함",
          "violationMessage": "멤버 변수 주석에는 용도와 제한사항을 기술해야 합니다"
        }
      ]
    },
    {
      "ruleId": "documentation.3_2_5",
      "title": "멤버 메소드 1) 메소드 상단에 위치한다 . 2) 주석 형식은 문서용 주석",
      "category": "documentation",
      "checkType": "static_analysis",
      "description": "메소드 선언 직전에 문서용 주석이 있는지 확인",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "멤버",
        "메소드",
        "1)",
        "상단에",
        "위치한다",
        "2)",
        "주석",
        "형식은",
        "문서용",
        "Exception"
      ],
      "examples": {
        "good": [
          "public LData t",
          "transferUsbk( LData usbkFtrnInp )"
        ],
        "bad": []
      },
      "sectionNumber": "3.2.5",
      "businessRules": [],
      "astHints": {},
      "contextualChecks": []
    },
    {
      "ruleId": "documentation.3_2_6",
      "title": "SQL 문 1) SQL statement 문 상단에 위치한다 . 2) 주석 형식은 XML",
      "category": "documentation",
      "checkType": "regex_with_validation",
      "description": "SQL 문에는 XML 주석 형식으로 작성된 헤더 주석이 필요하며, SQL statement 개요, WHERE 절 설명, 그리고 SELECT/INSERT/DELETE/UPDATE 절 다음에 작성자명, 소스코드 경로, statement명이 포함되어야 합니다.",
      "severity": "HIGH",
      "patterns": [
        {
          "pattern": "${stdd}",
          "flags": "g"
        },
        {
          "pattern": "${endt}",
          "flags": "g"
        },
        {
          "pattern": "${mngr",
          "flags": "g"
        },
        {
          "pattern": "${mngr",
          "flags": "g"
        },
        {
          "pattern": "${mngr",
          "flags": "g"
        },
        {
          "pattern": "<!--[\\s\\S]*?-->",
          "flags": "g",
          "description": "XML 주석 형식 검사"
        },
        {
          "pattern": "(SELECT|INSERT|DELETE|UPDATE)\\s*\\/\\*\\s*([^\\s]+)\\s+([^\\s]+)\\s+-\\s+([^\\s]+)\\s*\\*\\/",
          "flags": "gi",
          "description": "SQL 문 다음의 작성자명, 경로, statement명 주석 검사"
        }
      ],
      "customValidator": null,
      "keywords": [
        "SQL",
        "1)",
        "statement",
        "상단에",
        "위치한다",
        "2)",
        "주석",
        "형식은",
        "XML",
        "DB"
      ],
      "examples": {
        "good": [
          "DECODE(${mngr_empno}, '', 'Y', B.MNGR_EMPNO)",
          "DECODE(${mngr_empno}, '', 'Y', ${mngr_empno})",
          "<!-- 1) 날자별 List 조회 AND 상각시작일자 BETWEEN ${stdd} AND ${endt} -->\n<!-- 대손상각계좌목록조회 -->\n<statement name=\"retrieveListChofAcco\">\n<![CDATA[\nSELECT /* 이용규 /pln/fumn/spbn/chofBsicEBi/ChofAccoBsic.xml - retrieveListChofAcco */\n  A.SPPC_LEDGR_NO, A.LNBZ_ACNO\nFROM CLPCCHOFFD A\nWHERE A.LOAN_DT > SYSDATE\n]]>\n</statement>",
          "<!-- 사용자 정보 조회 -->\nSELECT /* 김개발 /user/UserMapper.xml - selectUser */\n  USER_ID, USER_NAME\nFROM TB_USER\nWHERE USER_ID = #{userId}"
        ],
        "bad": [
          "SELECT A.SPPC_LEDGR_NO, A.LNBZ_ACNO\nFROM CLPCCHOFFD A\nWHERE A.LOAN_DT > SYSDATE",
          "<!-- 사용자 정보 조회 -->\nSELECT USER_ID, USER_NAME\nFROM TB_USER\nWHERE USER_ID = #{userId}",
          "SELECT /* selectUser */\n  USER_ID, USER_NAME\nFROM TB_USER\nWHERE USER_ID = #{userId}"
        ]
      },
      "sectionNumber": "3.2.6",
      "businessRules": [
        "SQL statement 문 상단에 주석이 위치해야 한다",
        "주석 형식은 XML 주석(<!-- ... -->)을 사용해야 한다",
        "SQL statement 개요를 기술해야 한다 (필수)",
        "WHERE 절 등에 추가적인 설명이 필요한 조건에 대해서는 추가적인 설명을 기술해야 한다",
        "SELECT, INSERT, DELETE, UPDATE 절 바로 다음에 작성자명, 소스코드 경로, statement명을 주석으로 입력해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "Comment",
          "StringLiteral"
        ],
        "checkConditions": [
          "SQL 문이 포함된 문자열 리터럴 검사",
          "XML 주석 형식의 주석 노드 존재 확인",
          "SQL 키워드 다음의 주석 패턴 검사"
        ]
      },
      "contextualChecks": [
        {
          "condition": "SQL 문이 포함된 파일에서 XML 주석 존재 여부",
          "expectedBehavior": "SQL statement 상단에 <!-- --> 형식의 XML 주석이 있어야 함",
          "violationMessage": "SQL 문 상단에 XML 주석 형식의 개요 설명이 필요합니다"
        },
        {
          "condition": "SELECT, INSERT, DELETE, UPDATE 문 다음의 주석 형식",
          "expectedBehavior": "/* 작성자명 경로 - statement명 */ 형식의 주석이 있어야 함",
          "violationMessage": "SQL 문 다음에 작성자명, 소스코드 경로, statement명을 포함한 주석이 필요합니다"
        },
        {
          "condition": "복잡한 WHERE 절이나 상수 조건절 존재 시",
          "expectedBehavior": "해당 조건에 대한 추가 설명이 XML 주석에 포함되어야 함",
          "violationMessage": "복잡한 조건절에 대한 설명이 XML 주석에 포함되어야 합니다"
        }
      ]
    },
    {
      "ruleId": "documentation.3_2_7",
      "title": "기타 1) 코드 내부에 특별한 사항을 기술 할 경우 행 단위 주석 (//) 을 사용하지만",
      "category": "documentation",
      "checkType": "llm_contextual",
      "description": "코드 내부 주석 사용 가이드라인: 1) 행 단위 주석(//)은 특별한 사항 기술 시에만 사용하되 가급적 사용을 줄인다. 2) 짧은 statement나 멤버 변수 정의 시 같은 행에 주석 가능하나 충분한 간격을 둔다. 3) 주석은 라인 처음에서 시작한다. 4) 특별한 로직이나 실수하기 쉬운 부분이 아니면 코드 블록 내 주석 사용을 자제한다. 5) 주석이 필요하다면 코드를 더 깔끔하게 만들 방안을 먼저 고려한다. 6) BigDecimal 연산 시 로직 바로 위에 수식을 주석으로 표기한다.",
      "severity": "MEDIUM",
      "patterns": [
        {
          "pattern": "^\\s*//\\s*[^\\s]",
          "flags": "gm",
          "description": "라인 시작 주석 패턴"
        },
        {
          "pattern": "BigDecimal.*\\.multiply\\(|BigDecimal.*\\.add\\(|BigDecimal.*\\.subtract\\(|BigDecimal.*\\.divide\\(",
          "flags": "g",
          "description": "BigDecimal 연산 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "기타",
        "1)",
        "코드",
        "내부에",
        "특별한",
        "사항을",
        "기술",
        "경우",
        "단위",
        "주석"
      ],
      "examples": {
        "good": [
          "taWagImpRt = gdPriImpRt.multiply( tMul );",
          "multiply( tMul )",
          "// 기준임금인상률 = 물가상승률 * 기준 배수\ntaWagImpRt = gdPriImpRt.multiply(tMul);",
          "int count = 0;                    // 처리된 건수",
          "// 특별한 알고리즘 적용\nif (complexCondition) {\n    processSpecialCase();\n}"
        ],
        "bad": [
          "taWagImpRt = gdPriImpRt.multiply(tMul); // 계산",
          "int i = 0; // 카운터\nint j = 1; // 인덱스\nint k = 2; // 임시변수",
          "    // 들여쓰기된 주석",
          "// 불필요한 주석\nint sum = a + b;"
        ]
      },
      "sectionNumber": "3.2.7",
      "businessRules": [
        "코드 내부에 특별한 사항을 기술할 경우 행 단위 주석(//)을 사용하되 가급적 사용을 줄여야 한다",
        "매우 짧은 statement 뒤나 멤버 변수 정의 시 같은 행에 주석을 기재할 수 있다",
        "같은 행 주석 사용 시 코드와 충분한 간격을 두어 코드가 산만해지지 않도록 해야 한다",
        "주석의 시작은 항상 라인의 처음에서 시작해야 한다",
        "특별한 로직 구현이나 실수하기 쉬운 부분 강조가 아니라면 코드 블록 내 주석 사용을 자제해야 한다",
        "주석이 필요하다고 느껴지는 부분은 코드를 더 깔끔하게 만들 방안을 먼저 고려해야 한다",
        "BigDecimal 연산 수행 로직이 있을 경우 로직 바로 위에 연산식에 대한 수식을 주석으로 표기해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "LineComment",
          "VariableDeclarator",
          "MethodCallExpression"
        ],
        "checkConditions": [
          "주석이 라인 시작에 위치하는지 확인",
          "BigDecimal 연산 전에 수식 주석이 있는지 확인",
          "코드 블록 내 주석 빈도 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "코드 블록 내에 행 단위 주석이 과도하게 사용되는 경우",
          "expectedBehavior": "주석 사용을 최소화하고 코드 자체를 명확하게 작성",
          "violationMessage": "코드 블록 내 주석 사용이 과도합니다. 코드를 더 명확하게 작성하여 주석 필요성을 줄이세요."
        },
        {
          "condition": "주석이 라인 중간이나 들여쓰기된 위치에서 시작하는 경우",
          "expectedBehavior": "주석은 항상 라인의 처음에서 시작",
          "violationMessage": "주석은 항상 라인의 처음에서 시작해야 합니다."
        },
        {
          "condition": "BigDecimal 연산 로직 앞에 수식 설명 주석이 없는 경우",
          "expectedBehavior": "BigDecimal 연산 바로 위에 연산식에 대한 수식을 주석으로 표기",
          "violationMessage": "BigDecimal 연산 로직 앞에 연산식에 대한 수식을 주석으로 표기해야 합니다."
        },
        {
          "condition": "같은 행 주석 사용 시 코드와 간격이 부족한 경우",
          "expectedBehavior": "코드와 주석 사이에 충분한 간격(최소 4칸 이상)을 두어 가독성 확보",
          "violationMessage": "같은 행 주석 사용 시 코드와 충분한 간격을 두어야 합니다."
        },
        {
          "condition": "자명한 코드에 불필요한 주석이 달린 경우",
          "expectedBehavior": "특별한 로직이나 실수하기 쉬운 부분이 아니면 주석 사용 자제",
          "violationMessage": "자명한 코드에는 주석을 사용하지 마세요. 코드 자체가 충분히 명확해야 합니다."
        }
      ]
    },
    {
      "ruleId": "code_style.3_1_3",
      "title": "빈 줄 삽입 다음과 같은 경우에 하나의 빈 줄을 삽입한다 . 1) 주석과 Package 명",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "주석과 package 선언 사이의 빈 줄 패턴",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "삽입",
        "다음과",
        "같은",
        "경우에",
        "하나의",
        "줄을",
        "삽입한다",
        "1)",
        "주석과",
        "Package"
      ],
      "examples": {
        "good": [],
        "bad": []
      },
      "sectionNumber": "3.1.3",
      "businessRules": [],
      "astHints": {},
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_3_3",
      "title": "클래스 1) 클래스의 선언은 첫 번째 column 에서 시작한다 . 2) 선언이 여러 li",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "클래스 선언과 내부 구조에 대한 코딩 표준으로, 클래스 선언의 위치, 멀티라인 선언 시 들여쓰기, 클래스 내부 멤버의 선언 순서, static 변수 사용 원칙, 그리고 패키지명을 포함한 클래스명 사용 금지 등을 규정합니다.",
      "severity": "HIGH",
      "patterns": [
        {
          "pattern": "^\\s*public\\s+class\\s+\\w+",
          "flags": "gm",
          "description": "클래스 선언이 첫 번째 column에서 시작하는지 확인"
        },
        {
          "pattern": "\\w+\\.\\w+\\.\\w+\\.\\w+\\s+\\w+\\s*=",
          "flags": "g",
          "description": "패키지명을 포함한 클래스명 사용 패턴 감지"
        }
      ],
      "customValidator": null,
      "keywords": [
        "클래스",
        "1)",
        "클래스의",
        "선언은",
        "번째",
        "column",
        "에서",
        "시작한다",
        "2)",
        "선언이"
      ],
      "examples": {
        "good": [
          "cif = null ... ( X ) import sf.work010.entity.Tbcif10Entity;",
          "cif = serarchCustomer(custNo);",
          "public class L",
          "private Label l",
          "serarchCustomer(custNo)"
        ],
        "bad": [
          "    public class LoginView extends Frame implements ActionListener, TextListener {\n        // 클래스 선언이 첫 번째 column에서 시작하지 않음\n    }",
          "public class LoginView {\n    public void method1() {}\n    private String name;\n    private static final String TITLE = \"Login\";\n    public LoginView() {}\n    // 멤버 선언 순서가 잘못됨\n}",
          "public class CustomerService {\n    sf.work010.entity.Tbcif10Entity cif = null;\n    // 패키지명을 포함한 클래스명 사용\n}",
          "public class LoginView extends Frame \nimplements ActionListener, TextListener {\n// 멀티라인 선언 시 들여쓰기 없음\n}"
        ]
      },
      "sectionNumber": "3.3.3",
      "businessRules": [
        "클래스의 선언은 첫 번째 column에서 시작해야 한다",
        "선언이 여러 line에 걸쳐질 경우 적당한 기준으로 나누어 구성하며 들여쓰기를 사용해야 한다",
        "클래스 내부 선언 순서는 멤버 변수(상수→클래스 변수→인스턴스 변수), 멤버 메소드(클래스 선언 메소드→클래스 인스턴스 메소드→생성자→main→주요 기능) 순으로 배치해야 한다",
        "인스턴스 변수는 primitive 타입을 reference 타입보다 먼저 선언해야 한다",
        "생성자는 default constructor를 먼저, 그 다음 argument가 많은 순으로 배치해야 한다",
        "클래스(static) 변수는 반드시 모든 인스턴스에서 공유하고자 하는 경우만 사용해야 한다",
        "패키지명을 포함하는 클래스명은 사용하지 않고 import 선언문을 사용해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "ClassDeclaration",
          "FieldDeclaration",
          "MethodDeclaration",
          "ConstructorDeclaration",
          "ImportDeclaration"
        ],
        "checkConditions": [
          "클래스 선언의 시작 위치가 첫 번째 column인지 확인",
          "클래스 내부 멤버들의 선언 순서가 규칙에 맞는지 확인",
          "멀티라인 클래스 선언 시 들여쓰기 적용 여부 확인",
          "static 변수 사용의 적절성 확인",
          "import 문 없이 패키지명을 포함한 클래스명 사용 여부 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "클래스 선언이 첫 번째 column에서 시작하지 않는 경우",
          "expectedBehavior": "클래스 선언은 반드시 첫 번째 column에서 시작해야 함",
          "violationMessage": "클래스 선언은 첫 번째 column에서 시작해야 합니다"
        },
        {
          "condition": "클래스 내부 멤버의 선언 순서가 규칙과 다른 경우",
          "expectedBehavior": "상수→클래스 변수→인스턴스 변수→클래스 선언 메소드→클래스 인스턴스 메소드→생성자→main→주요 기능 순으로 배치",
          "violationMessage": "클래스 내부 멤버의 선언 순서가 코딩 표준을 위반합니다"
        },
        {
          "condition": "패키지명을 포함한 클래스명을 직접 사용하는 경우",
          "expectedBehavior": "import 선언문을 사용하고 클래스명만 사용해야 함",
          "violationMessage": "패키지명을 포함한 클래스명 대신 import 선언문을 사용하세요"
        },
        {
          "condition": "멀티라인 클래스 선언 시 들여쓰기가 없는 경우",
          "expectedBehavior": "여러 줄에 걸친 클래스 선언 시 적절한 들여쓰기 적용",
          "violationMessage": "멀티라인 클래스 선언 시 들여쓰기를 사용해야 합니다"
        }
      ]
    },
    {
      "ruleId": "code_style.3_3_4",
      "title": "클래스 메소드 1) 메소드 선언은 클래스가 선언된 컬럼에서 4 컬럼을 들여서 시작한다 .",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "클래스 메소드의 선언과 구현에 대한 포맷팅 및 구조 규칙을 정의합니다. 메소드 들여쓰기, 괄호와 공백 사용, 매개변수 정렬, 리소스 정리, 반환 타입 선언 등을 포함합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^(\\s{4})(public|private|protected)?\\s*(static)?\\s*\\w+\\s+\\w+\\s*\\(",
          "flags": "gm",
          "description": "메소드 선언의 들여쓰기 패턴 (4칸)"
        },
        {
          "pattern": "\\w+\\s+\\(",
          "flags": "g",
          "description": "메소드명과 여는 괄호 사이의 공백 검사 (공백이 있으면 위반)"
        },
        {
          "pattern": "\\(\\s+.*\\s+\\)",
          "flags": "g",
          "description": "괄호 내부 공백 패턴"
        },
        {
          "pattern": ",\\s*\\w+",
          "flags": "g",
          "description": "comma 뒤 공백 패턴"
        },
        {
          "pattern": "\\w+\\s*,",
          "flags": "g",
          "description": "comma 앞 공백 검사 (공백이 있으면 위반)"
        }
      ],
      "customValidator": null,
      "keywords": [
        "클래스",
        "메소드",
        "1)",
        "선언은",
        "클래스가",
        "선언된",
        "컬럼에서",
        "컬럼을",
        "들여서",
        "시작한다"
      ],
      "examples": {
        "good": [
          "open 한 파일의 close open 한 cursor 의 close open 한 데이터베이스 session 의 close open 한 소켓의 close 8) 더 이상 사용되지 않을 객체 인스턴스는 변수에 null 을 대입하여 제거한다 . 9) 각 메소드의 return",
          "showMsgbox()",
          "public class MyClass {\n    public void showMsgbox() {\n        // method body\n    }\n}",
          "public class MyClass {\n    public String processData( String input, int count ) {\n        return result;\n    }\n}",
          "public class MyClass {\n    public void multiLineMethod(\n            String firstParam,\n            int secondParam,\n            boolean thirdParam\n    ) {\n        // method body\n    }\n}"
        ],
        "bad": [
          "public class MyClass {\n  public void showMsgbox() {\n      // 잘못된 들여쓰기 (2칸)\n  }\n}",
          "public class MyClass {\n    public void showMsgbox () {\n        // 메소드명과 괄호 사이 공백\n    }\n}",
          "public class MyClass {\n    public String processData(String input,int count) {\n        // comma 뒤 공백 없음\n    }\n}",
          "public class MyClass {\n    public String processData(String input , int count) {\n        // comma 앞 공백 있음\n    }\n}",
          "public class MyClass {\n    public processData() {\n        // 반환 타입 누락\n    }\n}"
        ]
      },
      "sectionNumber": "3.3.4",
      "businessRules": [
        "메소드 선언은 클래스가 선언된 컬럼에서 4 컬럼을 들여서 시작해야 한다",
        "메소드의 이름과 여는 괄호 사이에는 공백을 두지 않아야 한다",
        "여는 괄호 뒤와 닫는 괄호 앞에는 적어도 하나 이상의 공백을 두어야 한다",
        "메소드에 인자가 없을 때에는 괄호 안에 아무것도 쓰지 않아야 한다",
        "매개변수를 comma로 분리할 때 comma 앞에는 공백을 두지 말고, 뒤에는 적어도 하나 이상의 공백을 두어야 한다",
        "선언이 여러 줄에 걸쳐질 경우 각 줄의 첫번째 매개변수를 정렬하고, 여는 괄호와 닫는 괄호를 정렬시켜야 한다",
        "필요한 경우 finally에서 cleanup operation을 수행해야 한다",
        "더 이상 사용되지 않을 객체 인스턴스는 변수에 null을 대입하여 제거해야 한다",
        "각 메소드의 return type을 명료하게 선언해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "MethodDeclaration",
          "FunctionDeclaration",
          "TryStatement",
          "FinallyBlock",
          "AssignmentExpression"
        ],
        "checkConditions": [
          "메소드 선언의 들여쓰기가 클래스 들여쓰기 + 4칸인지 확인",
          "메소드명과 괄호 사이 공백 여부 확인",
          "매개변수 목록의 공백 및 정렬 확인",
          "finally 블록에서 리소스 정리 코드 존재 확인",
          "null 할당을 통한 객체 정리 확인",
          "메소드 반환 타입 선언 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "메소드 선언의 들여쓰기 레벨 확인",
          "expectedBehavior": "클래스 내부 메소드는 클래스 선언보다 정확히 4칸 더 들여쓰기되어야 함",
          "violationMessage": "메소드 선언은 클래스 선언에서 4칸 들여쓰기해야 합니다"
        },
        {
          "condition": "finally 블록에서 리소스 정리 확인",
          "expectedBehavior": "파일, 커서, 데이터베이스 세션, 소켓 등의 리소스는 finally 블록에서 정리되어야 함",
          "violationMessage": "리소스는 finally 블록에서 정리해야 합니다"
        },
        {
          "condition": "사용하지 않는 객체의 null 할당 확인",
          "expectedBehavior": "더 이상 사용되지 않는 객체 인스턴스는 null을 할당하여 정리해야 함",
          "violationMessage": "사용하지 않는 객체는 null을 할당하여 정리해야 합니다"
        },
        {
          "condition": "메소드 반환 타입 선언 확인",
          "expectedBehavior": "모든 메소드는 명확한 반환 타입을 가져야 하며, 반환값이 없으면 void로 선언해야 함",
          "violationMessage": "메소드의 반환 타입을 명확하게 선언해야 합니다"
        }
      ]
    },
    {
      "ruleId": "code_style.3_3_5",
      "title": "변수 1) 멤버 변수 기술 순서는 constant - > static - > primiti",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "Java 클래스의 멤버 변수는 constant → static → primitive → reference 순서로 선언하고, 적절한 들여쓰기, 초기화, 명명 규칙을 준수해야 합니다.",
      "severity": "HIGH",
      "patterns": [
        {
          "pattern": "\\bfor\\s*\\(\\s*int\\s+[ijk]\\s*[=;]",
          "flags": "g",
          "description": "Loop 변수에서 i, j, k 사용 금지 패턴"
        },
        {
          "pattern": "\\bfor\\s*\\(\\s*int\\s+(inx|jnx|knx)\\s*=",
          "flags": "g",
          "description": "올바른 Loop 변수 명명 패턴 (inx, jnx, knx)"
        },
        {
          "pattern": "\\w+\\s*\\[\\s*\\]\\s+\\w+",
          "flags": "g",
          "description": "올바른 배열 선언 패턴 (type[] arrayname)"
        },
        {
          "pattern": "\\w+\\s+\\w+\\s*\\[\\s*\\]",
          "flags": "g",
          "description": "잘못된 배열 선언 패턴 (type arrayname[])"
        },
        {
          "pattern": ";\\s+$",
          "flags": "gm",
          "description": "세미콜론 앞 공백 검사 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "변수",
        "1)",
        "멤버",
        "기술",
        "순서는",
        "constant",
        "static",
        "primiti",
        "class",
        "메소드"
      ],
      "examples": {
        "good": [
          "memberNameStr = null;",
          "rentalItemStr = null;",
          "public class L",
          "private Label l",
          "confirmRentalInfo()"
        ],
        "bad": [
          "public class LoginView {\n    private Label lblTitle;\n    private int userId;\n    private static final String TITLE = \"Login\";\n}",
          "for (int i = 0; i < MAX; i++) {\n    // loop body\n}",
          "private String address[] = new String[5];",
          "String memberNameStr, rentalItemStr;",
          "private Label lblTitle ;"
        ]
      },
      "sectionNumber": "3.3.5",
      "businessRules": [
        "멤버 변수 선언 순서는 constant → static → primitive → reference 변수 순으로 해야 한다",
        "클래스의 멤버 변수 선언은 클래스 선언 첫번째 컬럼으로부터 4칸 들여쓰기를 해야 한다",
        "한 line에 하나의 변수만 선언해야 한다",
        "마지막 semicolon 앞에 공백을 두지 않아야 한다",
        "같은 Type의 변수는 가급적 그룹을 지어 선언해야 한다",
        "Loop 변수는 Loop 내에서 선언하여 사용해야 한다",
        "Loop 변수는 inx, jnx, knx 형식을 사용하며 i, j, k를 사용하지 않아야 한다",
        "쓰이지 않는 멤버변수 또는 로컬변수는 선언하지 않아야 한다",
        "멤버변수는 필요 시에 생성자나 메소드 내에서 초기화해야 한다",
        "자동(로컬) 변수는 선언 시 반드시 초기화해야 한다",
        "flag 변수, 누적 counter, return code를 저장하는 변수 등은 반드시 초기화해야 한다",
        "Array 선언은 type[] arrayname 형식으로 선언해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "ClassDeclaration",
          "FieldDeclaration",
          "VariableDeclarator",
          "ForStatement",
          "VariableDeclarationStatement"
        ],
        "checkConditions": [
          "클래스 내 필드 선언 순서 검사 (constant → static → primitive → reference)",
          "필드 선언의 들여쓰기 레벨 검사 (4칸)",
          "한 줄에 하나의 변수 선언 검사",
          "같은 타입 변수들의 그룹핑 검사",
          "for문 내 변수 선언 위치 검사",
          "변수 초기화 상태 검사",
          "배열 선언 형식 검사"
        ]
      },
      "contextualChecks": [
        {
          "condition": "클래스 내 멤버 변수 선언 순서",
          "expectedBehavior": "constant 변수, static 변수, primitive 변수, reference 변수 순서로 선언",
          "violationMessage": "멤버 변수 선언 순서가 올바르지 않습니다. constant → static → primitive → reference 순서로 선언해야 합니다."
        },
        {
          "condition": "변수 선언 시 들여쓰기",
          "expectedBehavior": "클래스 선언 첫번째 컬럼으로부터 4칸 들여쓰기",
          "violationMessage": "멤버 변수 선언 시 4칸 들여쓰기를 해야 합니다."
        },
        {
          "condition": "Loop 변수 명명",
          "expectedBehavior": "inx, jnx, knx 형식 사용, i, j, k 사용 금지",
          "violationMessage": "Loop 변수는 inx, jnx, knx 형식을 사용해야 하며, i, j, k를 사용하지 않아야 합니다."
        },
        {
          "condition": "로컬 변수 초기화",
          "expectedBehavior": "선언 시 반드시 초기화",
          "violationMessage": "로컬 변수는 선언 시 반드시 초기화해야 합니다."
        }
      ]
    },
    {
      "ruleId": "code_style.3_6_1",
      "title": "공통 1) 두 문장을 한 줄에 코딩하지 않는다 . 2) 중첩된 문장에서는 상위문장의 시작에",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "코드 포맷팅 및 들여쓰기 규칙: 1) 한 줄에 두 개 이상의 문장을 작성하지 않음, 2) 중첩된 문장에서 상위문장 기준으로 들여쓰기 적용, 3) 여는 brace 다음 라인에 들여쓰기 적용, 4) 여는 괄호와 닫는 괄호의 적절한 위치 배치",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": ";\\s*[^\\s\\n\\r}]",
          "flags": "g",
          "description": "세미콜론 후 같은 줄에 다른 문장이 있는지 검사"
        },
        {
          "pattern": "\\{\\s*[^\\s\\n\\r}]",
          "flags": "g",
          "description": "여는 brace 후 같은 줄에 코드가 있는지 검사"
        }
      ],
      "customValidator": null,
      "keywords": [
        "공통",
        "1)",
        "문장을",
        "줄에",
        "코딩하지",
        "않는다",
        "2)",
        "중첩된",
        "문장에서는",
        "상위문장의"
      ],
      "examples": {
        "good": [
          "getDatafile( \"input.dat\" )",
          "getDatafile( \"output.dat\" )",
          "if (condition) {\n    statement1;\n    statement2;\n}",
          "if (((inputFile = getDatafile(\"input.dat\")) != null) &&\n    ((outputFile = getDatafile(\"output.dat\")) != null)) {\n    // code here\n}",
          "for (int i = 0; i < length; i++) {\n    processItem(i);\n}"
        ],
        "bad": [
          "if (condition) { statement1; statement2; }",
          "var x = 1; var y = 2;",
          "if (condition) { doSomething(); } else { doOther(); }",
          "for (int i = 0; i < length; i++) { processItem(i); }",
          "if (((inputFile = getDatafile(\"input.dat\")) != null) && ((outputFile = getDatafile(\"output.dat\")) != null)) { /* code */ }"
        ]
      },
      "sectionNumber": "3.6.1",
      "businessRules": [
        "두 문장을 한 줄에 코딩하지 않는다",
        "중첩된 문장에서는 상위문장의 시작에서 들여쓰기를 한다",
        "여는 brace 다음 라인에 들여쓰기를 한다",
        "여는 괄호와 닫는 괄호는 같은 line에 위치시킨다",
        "닫는 괄호를 같은 line에 위치시킬 수 없을 때는 여는 괄호와 같은 column에 정렬하여 새로운 line의 처음에 둔다"
      ],
      "astHints": {
        "nodeTypes": [
          "BlockStatement",
          "IfStatement",
          "ForStatement",
          "WhileStatement",
          "FunctionDeclaration",
          "MethodDeclaration"
        ],
        "checkConditions": [
          "한 줄에 여러 문장이 있는지 확인",
          "중첩된 블록의 들여쓰기 레벨 확인",
          "brace 다음 줄의 들여쓰기 확인",
          "괄호의 위치와 정렬 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "한 줄에 세미콜론으로 구분된 두 개 이상의 문장이 있는 경우",
          "expectedBehavior": "각 문장을 별도의 줄에 작성",
          "violationMessage": "두 문장을 한 줄에 코딩하지 않아야 합니다"
        },
        {
          "condition": "중첩된 블록에서 들여쓰기가 일관되지 않은 경우",
          "expectedBehavior": "상위문장 기준으로 일관된 들여쓰기 적용",
          "violationMessage": "중첩된 문장에서는 상위문장의 시작에서 들여쓰기를 해야 합니다"
        },
        {
          "condition": "여는 brace 다음에 같은 줄에 코드가 있는 경우",
          "expectedBehavior": "여는 brace 다음 줄부터 들여쓰기하여 코드 작성",
          "violationMessage": "여는 brace 다음 라인에 들여쓰기를 해야 합니다"
        },
        {
          "condition": "괄호의 위치가 부적절한 경우",
          "expectedBehavior": "여는 괄호와 닫는 괄호를 같은 줄에 위치시키거나, 불가능한 경우 여는 괄호와 같은 column에 정렬",
          "violationMessage": "괄호의 위치가 가이드라인을 따르지 않습니다"
        }
      ]
    },
    {
      "ruleId": "code_style.3_6_2",
      "title": "Compound statement 1) 메소드 body 내에서의 모든 선언문이나 문장은 들",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "메소드 body 내의 모든 선언문과 문장은 적절한 들여쓰기를 적용해야 하며, 중괄호 배치 규칙을 준수해야 합니다. 여는 중괄호는 해당 문장의 끝에, 닫는 중괄호는 여는 중괄호를 시작하는 문장의 들여쓰기 위치에 맞춰 배치합니다. 빈 블록의 경우 중괄호 대신 세미콜론을 사용합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "\\{\\s*\\}",
          "flags": "g",
          "description": "빈 중괄호 블록 검출 (세미콜론으로 대체해야 함)"
        },
        {
          "pattern": "^(\\s*)(if|for|while|else)\\s*\\([^)]*\\)\\s*\\{\\s*$",
          "flags": "gm",
          "description": "제어문 후 여는 중괄호가 같은 줄에 있는지 확인"
        },
        {
          "pattern": "^(\\s*)\\}\\s*$",
          "flags": "gm",
          "description": "닫는 중괄호의 들여쓰기 위치 확인"
        }
      ],
      "customValidator": null,
      "keywords": [
        "Compound",
        "statement",
        "1)",
        "메소드",
        "body",
        "내에서의",
        "모든",
        "선언문이나",
        "문장은"
      ],
      "examples": {
        "good": [
          "Count = 0;",
          "i = 0 ;",
          "private void s",
          "showSerial()",
          "getSerialNo()"
        ],
        "bad": [
          "private void showSerial()\n{\n    int Count = 0;\nif (stTape.getSerialNo() == null)\n{\nparentFrame.showWarningDialog(\"시리얼 번호 검색오류\");\ntfSerialNo.selectAll();\n}\n}",
          "for (int i = 0; i < MAX_COUNT; i++) {}",
          "while (i-- > MAX_COUNT) {}"
        ]
      },
      "sectionNumber": "3.6.2",
      "businessRules": [
        "메소드 body 내에서의 모든 선언문이나 문장은 들여쓰기를 해야 한다",
        "여는 brace는 사용하고자 하는 곳의 제일 끝에 위치해야 한다",
        "닫는 brace는 여는 brace를 시작하는 문장에 들여쓰기 위치에 맞춰야 한다",
        "중괄호 안에 기술할 내용이 없다면 중괄호 대신에 세미콜론을 사용해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "MethodDeclaration",
          "BlockStatement",
          "IfStatement",
          "ForStatement",
          "WhileStatement"
        ],
        "checkConditions": [
          "메소드 내부의 모든 문장이 적절히 들여쓰기되어 있는지 확인",
          "중괄호의 위치가 규칙에 맞는지 확인",
          "빈 블록이 세미콜론으로 대체되어 있는지 확인",
          "블록 내부의 들여쓰기 일관성 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "메소드 body 내의 모든 문장이 들여쓰기되어 있는가",
          "expectedBehavior": "메소드 내부의 모든 선언문과 실행문이 일정한 들여쓰기(보통 4칸 또는 1탭)를 가져야 함",
          "violationMessage": "메소드 body 내의 문장이 적절히 들여쓰기되지 않았습니다"
        },
        {
          "condition": "여는 중괄호가 해당 문장의 끝에 위치하는가",
          "expectedBehavior": "if, for, while, 메소드 선언 등의 여는 중괄호는 같은 줄 끝에 위치해야 함",
          "violationMessage": "여는 중괄호가 문장의 끝에 위치하지 않습니다"
        },
        {
          "condition": "닫는 중괄호가 적절한 들여쓰기 위치에 있는가",
          "expectedBehavior": "닫는 중괄호는 해당 블록을 시작하는 문장과 같은 들여쓰기 레벨에 위치해야 함",
          "violationMessage": "닫는 중괄호의 들여쓰기 위치가 올바르지 않습니다"
        },
        {
          "condition": "빈 블록이 세미콜론으로 대체되어 있는가",
          "expectedBehavior": "내용이 없는 블록은 {} 대신 ;을 사용해야 함",
          "violationMessage": "빈 블록은 중괄호 대신 세미콜론을 사용해야 합니다"
        }
      ]
    },
    {
      "ruleId": "code_style.3_6_3",
      "title": "The for statement 1) for 다음 공백 , 괄호 열고 공백 , 내용 쓰고",
      "category": "code_style",
      "checkType": "regex_with_validation",
      "description": "for문의 공백 사용 규칙을 검사합니다. for 키워드 다음 공백, 괄호 내부 양쪽 공백, 세미콜론 양쪽 공백, 그리고 적절한 들여쓰기와 줄바꿈을 확인합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "for\\s*\\(",
          "flags": "g",
          "description": "for 키워드와 여는 괄호 사이의 공백 검사"
        },
        {
          "pattern": "for\\s+\\(\\s+[^;]+\\s*;\\s*[^;]*\\s*;\\s*[^)]*\\s+\\)",
          "flags": "g",
          "description": "for문의 전체 공백 패턴 검사"
        }
      ],
      "customValidator": null,
      "keywords": [
        "The",
        "for",
        "statement",
        "1)",
        "다음",
        "공백",
        "괄호",
        "열고",
        "내용",
        "쓰고"
      ],
      "examples": {
        "good": [
          "inx = 0 ;",
          "getItemCount()",
          "RentalItemEntity()",
          "for ( inx = 0 ; inx < nSamples ; inx++ )\n    accum += samples[inx];",
          "for ( int inx = 0 ; inx < lstRentalList.getItemCount() ; inx++ )\n{\n    rentalItem = new RentalItemEntity();\n    rentalItemVect.addElement( rentalItem );\n}"
        ],
        "bad": [
          "for(inx=0;inx<nSamples;inx++)\naccum += samples[inx];",
          "for( inx = 0; inx < nSamples; inx++ )\naccum += samples[inx];",
          "for (inx = 0;inx < nSamples;inx++)\naccum += samples[inx];"
        ]
      },
      "sectionNumber": "3.6.3",
      "businessRules": [
        "for 키워드 다음에 공백을 넣어야 한다",
        "여는 괄호 다음과 닫는 괄호 전에 공백을 넣어야 한다",
        "for문 내 세미콜론 양쪽에 적어도 한 칸 이상의 공백을 넣어야 한다",
        "for문에 부속되는 문장은 다음 줄에 들여쓰기를 해야 한다",
        "조건식이 한 줄에 들어가지 않을 때는 조건식 단위로 줄을 나누고 정렬해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "ForStatement"
        ],
        "checkConditions": [
          "for 키워드와 괄호 사이의 공백 확인",
          "괄호 내부 양쪽 공백 확인",
          "세미콜론 주변 공백 확인",
          "for문 본문의 들여쓰기 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "for문의 조건식이 한 줄에 들어가지 않는 경우",
          "expectedBehavior": "조건식 단위로 줄을 나누고 정렬해야 함",
          "violationMessage": "긴 for문 조건식은 적절히 줄바꿈하고 정렬해야 합니다"
        },
        {
          "condition": "for문에 부속되는 문장이 있는 경우",
          "expectedBehavior": "다음 줄에 들여쓰기를 적용해야 함",
          "violationMessage": "for문 본문은 적절히 들여쓰기되어야 합니다"
        }
      ]
    },
    {
      "ruleId": "code_style.3_6_4",
      "title": "The while Statement 1) while 다음에 공백을 넣고 , 괄호 열고 공백",
      "category": "code_style",
      "checkType": "regex",
      "description": "while 문의 형식 규칙: 1) while 키워드 다음에 공백, 여는 괄호 다음에 공백, 닫는 괄호 전에 공백을 둔다. 2) while 문의 본문은 다음 줄에 들여쓰기하여 작성한다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "while\\s*\\(\\s*[^)]+\\s*\\)\\s*\\{",
          "flags": "g",
          "description": "올바른 while 문 형식 검사 - while 다음 공백, 괄호 안 양쪽 공백"
        },
        {
          "pattern": "while\\([^)]*\\)",
          "flags": "g",
          "description": "잘못된 while 문 형식 검사 - while 다음 공백 없음"
        },
        {
          "pattern": "while\\s+\\([^\\s][^)]*[^\\s]\\)",
          "flags": "g",
          "description": "잘못된 while 문 형식 검사 - 괄호 안 공백 없음"
        }
      ],
      "customValidator": null,
      "keywords": [
        "The",
        "while",
        "Statement",
        "1)",
        "다음에",
        "공백을",
        "넣고",
        "괄호",
        "열고",
        "공백"
      ],
      "examples": {
        "good": [
          "next()",
          "ClubMemberShipEntity( result.getString(1)",
          "while ( result.next() ) {\n    member = new ClubMemberShipEntity();\n    vect.addElement( member );\n}",
          "while ( count < 10 ) {\n    count++;\n    process();\n}"
        ],
        "bad": [
          "while(result.next()) {\n    member = new ClubMemberShipEntity();\n}",
          "while (result.next()) {\n    member = new ClubMemberShipEntity();\n}",
          "while ( result.next()) {\n    member = new ClubMemberShipEntity();\n}",
          "while (result.next() ) {\n    member = new ClubMemberShipEntity();\n}"
        ]
      },
      "sectionNumber": "3.6.4",
      "businessRules": [
        "while 키워드 다음에 반드시 공백을 둔다",
        "while 조건문의 여는 괄호 다음에 공백을 둔다",
        "while 조건문의 닫는 괄호 전에 공백을 둔다",
        "while 문의 본문은 다음 줄에 들여쓰기하여 작성한다"
      ],
      "astHints": {
        "nodeTypes": [
          "WhileStatement"
        ],
        "checkConditions": [
          "while 키워드와 조건문 괄호 사이의 공백 확인",
          "조건문 괄호 내부 양쪽 공백 확인",
          "while 문 본문의 들여쓰기 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_6_5",
      "title": "The do statement 1) do keyword 를 한 line 자체에 둔다 . 2",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "do-while 문의 형식 규칙: 1) do 키워드는 독립된 라인에 위치, 2) do 블록 내용은 들여쓰기, 3) while 키워드 주변 공백 규칙 준수, 4) while 조건문 후 세미콜론으로 종료",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^\\s*do\\s*$",
          "flags": "gm",
          "description": "do 키워드가 독립된 라인에 있는지 검사"
        },
        {
          "pattern": "\\}\\s*while\\s+\\(\\s+.+\\s+\\)\\s*;",
          "flags": "g",
          "description": "while 조건문의 공백 규칙과 세미콜론 종료 검사"
        }
      ],
      "customValidator": null,
      "keywords": [
        "The",
        "do",
        "statement",
        "1)",
        "keyword",
        "line",
        "자체에",
        "둔다"
      ],
      "examples": {
        "good": [
          "semicolon(;)",
          "do\n{\n    statement1;\n    statement2;\n}\nwhile ( condition );",
          "do\n{\n    processData();\n    updateCounter++;\n}\nwhile ( isValid );",
          "do\n{\n    x++;\n}\nwhile ( x < 10 );"
        ],
        "bad": [
          "do { statement; } while (condition);",
          "do\n{\n    statement;\n} while(condition);",
          "do\n{\nstatement;\n}\nwhile ( condition )",
          "do\n{\n    statement;\n}\nwhile (condition);",
          "do\n{\n    statement;\n}\nwhile( condition );"
        ]
      },
      "sectionNumber": "3.6.5",
      "businessRules": [
        "do 키워드를 한 line 자체에 둔다",
        "do 문장을 구성하는 문장은 다음 줄에 들여쓰기를 한다",
        "while 다음에 공백을 넣고, 괄호 열고 공백, 내용 쓰고 괄호 닫기 전에 공백을 넣어야 한다",
        "while 문장이 끝나면 닫는 괄호 뒤에 terminating semicolon(;)을 쓴다"
      ],
      "astHints": {
        "nodeTypes": [
          "DoWhileStatement"
        ],
        "checkConditions": [
          "do 키워드가 독립된 라인에 위치하는지 확인",
          "do 블록 내용이 적절히 들여쓰기되어 있는지 확인",
          "while 키워드 주변 공백이 규칙에 맞는지 확인",
          "while 조건문 괄호 내부에 공백이 있는지 확인",
          "while 문 끝에 세미콜론이 있는지 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "do-while 문이 발견되었을 때",
          "expectedBehavior": "do 키워드는 독립된 라인에 위치하고, 블록 내용은 들여쓰기되며, while 조건문은 공백 규칙을 준수하고 세미콜론으로 종료되어야 함",
          "violationMessage": "do-while 문의 형식이 코딩 표준을 위반합니다"
        }
      ]
    },
    {
      "ruleId": "code_style.3_6_6",
      "title": "The if and if - else Statement 1) if 다음에 공백을 넣고 ,",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "if문과 if-else문의 형식 규칙: 1) if 키워드 다음에 공백, 괄호 열고 공백, 조건식, 공백 후 괄호 닫기 2) if문 본문은 다음 줄에 들여쓰기 3) else문도 동일한 형식 적용 4) 한 줄 문장이라도 반드시 중괄호 사용",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "if\\s*\\(\\s*.+\\s*\\)\\s*\\{",
          "flags": "g",
          "description": "if문의 기본 형식 패턴"
        },
        {
          "pattern": "else\\s+if\\s*\\(\\s*.+\\s*\\)\\s*\\{",
          "flags": "g",
          "description": "else if문의 형식 패턴"
        },
        {
          "pattern": "else\\s*\\{",
          "flags": "g",
          "description": "else문의 형식 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "The",
        "if",
        "and",
        "else",
        "Statement",
        "1)",
        "다음에",
        "공백을",
        "넣고"
      ],
      "examples": {
        "good": [
          "getSerialNo()",
          "showWarningDialog( \" 시리얼 번호 검색오류 \" )",
          "if ( condition ) {\n    statement;\n}",
          "if ( stTape.getSerialNo() == 0 ) {\n    parentFrame.showWarningDialog(\"error\");\n} else if ( stTape.getSerialNo() == 1 ) {\n    parentFrame.showWarningDialog(\"admin only\");\n} else {\n    tfDailyPrice.setText(price);\n}"
        ],
        "bad": [
          "if(condition) statement;",
          "if(condition){\n    statement;\n}",
          "if ( condition ) statement;",
          "if(condition) {\nstatement;\n}",
          "else if(condition) {\n    statement;\n}"
        ]
      },
      "sectionNumber": "3.6.6",
      "businessRules": [
        "if 키워드 다음에 공백을 넣어야 한다",
        "괄호 열고 공백, 조건식 작성 후 공백을 두고 괄호를 닫아야 한다",
        "if문과 else문의 본문은 다음 줄에 들여쓰기를 해야 한다",
        "문장이 한 줄이라도 반드시 중괄호를 사용해야 한다",
        "else문도 if문과 동일한 형식을 따라야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "IfStatement",
          "BlockStatement"
        ],
        "checkConditions": [
          "if 키워드와 조건식 괄호 사이에 공백이 있는지 확인",
          "조건식 괄호 내부 양쪽에 공백이 있는지 확인",
          "if문 본문이 중괄호로 감싸져 있는지 확인",
          "본문이 다음 줄에 들여쓰기되어 있는지 확인",
          "else문도 동일한 형식을 따르는지 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "if문이나 else문에서 중괄호 없이 단일 문장 사용",
          "expectedBehavior": "한 줄 문장이라도 반드시 중괄호로 감싸야 함",
          "violationMessage": "if/else문은 한 줄이라도 반드시 중괄호를 사용해야 합니다"
        },
        {
          "condition": "if 키워드와 조건식 괄호 사이에 공백 누락",
          "expectedBehavior": "if 다음에 공백을 넣고 괄호 시작",
          "violationMessage": "if 키워드 다음에 공백이 필요합니다"
        },
        {
          "condition": "조건식 괄호 내부에 공백 누락",
          "expectedBehavior": "괄호 열고 공백, 조건식, 공백 후 괄호 닫기",
          "violationMessage": "조건식 괄호 내부 양쪽에 공백이 필요합니다"
        }
      ]
    },
    {
      "ruleId": "code_style.3_6_7",
      "title": "The switch Statement 1) switch keyword 와 Test Expr",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "switch 문의 구조적 형식과 스타일을 검사합니다. switch 키워드와 테스트 표현식이 같은 줄에 위치하고, 적절한 공백과 들여쓰기가 적용되며, case/default 레이블이 올바르게 정렬되고 각각 별도 줄에 위치해야 합니다.",
      "severity": "MEDIUM",
      "patterns": [
        {
          "pattern": "switch\\s*\\(\\s*.+\\s*\\)\\s*\\{",
          "flags": "g",
          "description": "switch 문의 기본 구조와 공백 패턴"
        },
        {
          "pattern": "^\\s*(case\\s+.+:|default\\s*:)\\s*$",
          "flags": "gm",
          "description": "case/default 레이블이 별도 줄에 위치하는 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "The",
        "switch",
        "Statement",
        "1)",
        "keyword",
        "Test",
        "Expr"
      ],
      "examples": {
        "good": [
          "delete()",
          "switch ( respCode ) {\n    case 1:\n        add();\n        break;\n    case 2:\n        delete();\n        break;\n    default:\n        System.out.println( err_msg );\n        break;\n}",
          "switch ( status ) {\n    case ACTIVE:\n        processActive();\n        break;\n    case INACTIVE:\n        processInactive();\n        break;\n    default:\n        handleDefault();\n        break;\n}"
        ],
        "bad": [
          "switch(respCode){\ncase 1: add(); break;\ncase 2: delete(); break;\ndefault: System.out.println(err_msg);\n}",
          "switch ( respCode ) {\ncase 1: case 2:\n    process();\n    break;\ndefault:\n    handleDefault();\n}",
          "switch ( respCode )\n{\n        case 1:\n    add();\n    break;\n    case 2:\n        delete();\n        break;\n}"
        ]
      },
      "sectionNumber": "3.6.7",
      "businessRules": [
        "switch 키워드와 Test Expression을 같은 줄에 작성해야 한다",
        "switch 키워드 다음에 공백, 여는 괄호 다음에 공백, 닫는 괄호 전에 공백을 둬야 한다",
        "case와 default 레이블을 switch 키워드 다음에 들여쓰기하여 정렬해야 한다",
        "한 줄에 하나 이상의 case나 default 레이블을 두지 않아야 한다",
        "case나 default 레이블의 표현식은 case 키워드 시작으로부터 들여쓰기해야 한다",
        "default 레이블 사용을 권장한다",
        "default case에도 가능하면 break를 사용해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "SwitchStatement",
          "SwitchCase"
        ],
        "checkConditions": [
          "switch 키워드와 테스트 표현식이 같은 줄에 위치",
          "괄호 주변 공백 존재",
          "case/default 레이블의 들여쓰기 일관성",
          "각 case/default가 별도 줄에 위치",
          "default case 존재 여부",
          "default case의 break 문 존재"
        ]
      },
      "contextualChecks": [
        {
          "condition": "switch 키워드와 테스트 표현식이 다른 줄에 위치",
          "expectedBehavior": "switch 키워드와 테스트 표현식을 같은 줄에 작성",
          "violationMessage": "switch 키워드와 테스트 표현식은 같은 줄에 작성해야 합니다"
        },
        {
          "condition": "괄호 주변에 공백이 없음",
          "expectedBehavior": "switch 키워드 다음, 여는 괄호 다음, 닫는 괄호 전에 공백 추가",
          "violationMessage": "switch 문의 괄호 주변에 적절한 공백을 추가해야 합니다"
        },
        {
          "condition": "case/default 레이블의 들여쓰기가 일관되지 않음",
          "expectedBehavior": "모든 case/default 레이블을 동일한 수준으로 들여쓰기",
          "violationMessage": "case와 default 레이블의 들여쓰기가 일관되지 않습니다"
        },
        {
          "condition": "한 줄에 여러 case 레이블이 존재",
          "expectedBehavior": "각 case/default 레이블을 별도 줄에 작성",
          "violationMessage": "한 줄에 하나 이상의 case나 default 레이블을 사용할 수 없습니다"
        },
        {
          "condition": "default 레이블이 없음",
          "expectedBehavior": "프로그램 판독성을 위해 default 레이블 추가",
          "violationMessage": "프로그램의 판독성을 높이기 위해 default 레이블 사용을 권장합니다"
        },
        {
          "condition": "default case에 break가 없음",
          "expectedBehavior": "default case에도 break 문 추가",
          "violationMessage": "향후 새로운 case 추가 시 발생할 수 있는 실수를 방지하기 위해 default case에도 break를 추가하는 것을 권장합니다"
        }
      ]
    },
    {
      "ruleId": "code_style.3_6_8",
      "title": "try - catch statement 1) try keyword 를 한 line 자체에",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "try-catch 문의 형식과 들여쓰기 규칙을 정의합니다. try 키워드는 독립된 라인에 위치하고, catch와 finally 키워드는 try와 같은 컬럼에 정렬되어야 하며, 각 블록의 내용은 적절히 들여쓰기되어야 합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^\\s*try\\s*\\{\\s*$",
          "flags": "gm",
          "description": "try 키워드가 독립된 라인에 있는지 확인"
        },
        {
          "pattern": "^(\\s*)try\\s*\\{[\\s\\S]*?^\\1catch\\s*\\(\\s*\\w+\\s+\\w+\\s*\\)\\s*\\{",
          "flags": "gm",
          "description": "try와 catch의 들여쓰기 정렬 확인"
        },
        {
          "pattern": "catch\\s*\\(\\s*\\w+\\s+\\w+\\s*\\)",
          "flags": "g",
          "description": "catch 괄호 내 공백 형식 확인"
        }
      ],
      "customValidator": null,
      "keywords": [
        "try",
        "catch",
        "statement",
        "1)",
        "keyword",
        "line",
        "자체에",
        "Exception",
        "column",
        "변수"
      ],
      "examples": {
        "good": [
          "dailyPrice = Integer.parseInt( tfDailyPrice.getText() );",
          "parseInt( tfDailyPrice.getText()",
          "println( \"NumberFormat Exception\" )",
          "try {\n    dailyPrice = Integer.parseInt(tfDailyPrice.getText());\n} catch ( NumberFormatException e ) {\n    System.out.println(\"NumberFormat Exception\");\n    return;\n}",
          "try {\n    processData();\n} catch ( IOException e ) {\n    handleError(e);\n} finally {\n    cleanup();\n}"
        ],
        "bad": [
          "try { dailyPrice = Integer.parseInt(tfDailyPrice.getText()); } catch (NumberFormatException e) { return; }",
          "try {\n    processData();\n    } catch (IOException e) {\n    handleError(e);\n}",
          "try {\n    processData();\n} catch(IOException e){\n    handleError(e);\n}"
        ]
      },
      "sectionNumber": "3.6.8",
      "businessRules": [
        "try 키워드는 한 라인에 독립적으로 위치해야 한다",
        "try 문장 내용은 다음 줄에 들여쓰기되어야 한다",
        "catch 키워드는 try와 같은 컬럼에 정렬되어야 한다",
        "catch 다음에는 공백, 괄호 열기, 공백, Exception명과 변수명, 공백, 괄호 닫기 순서로 작성해야 한다",
        "catch 블록 내용은 4칸 이상 들여쓰기되어야 한다",
        "finally 키워드가 필요한 경우 try와 같은 컬럼에 정렬되어야 한다",
        "finally 블록 내용은 들여쓰기되어야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "TryStatement",
          "CatchClause",
          "Block"
        ],
        "checkConditions": [
          "try 키워드의 라인 독립성 확인",
          "try, catch, finally 키워드의 컬럼 정렬 확인",
          "각 블록 내용의 들여쓰기 레벨 확인",
          "catch 문의 매개변수 형식 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "try 키워드가 다른 코드와 같은 라인에 있는 경우",
          "expectedBehavior": "try 키워드는 독립된 라인에 위치해야 함",
          "violationMessage": "try 키워드는 한 라인에 독립적으로 위치해야 합니다"
        },
        {
          "condition": "catch 또는 finally 키워드가 try와 다른 들여쓰기 레벨에 있는 경우",
          "expectedBehavior": "try, catch, finally 키워드는 같은 컬럼에 정렬되어야 함",
          "violationMessage": "catch와 finally 키워드는 try 키워드와 같은 컬럼에 정렬되어야 합니다"
        },
        {
          "condition": "catch 문의 괄호 내에 적절한 공백이 없는 경우",
          "expectedBehavior": "catch 다음에 공백, 괄호 열기, 공백, Exception명과 변수명, 공백, 괄호 닫기 순서",
          "violationMessage": "catch 문의 괄호 내에 적절한 공백을 넣어야 합니다: catch ( ExceptionType variableName )"
        },
        {
          "condition": "try, catch, finally 블록 내용이 적절히 들여쓰기되지 않은 경우",
          "expectedBehavior": "각 블록의 내용은 4칸 이상 들여쓰기되어야 함",
          "violationMessage": "try-catch-finally 블록 내용은 4칸 이상 들여쓰기되어야 합니다"
        }
      ]
    },
    {
      "ruleId": "code_style.3_7_1",
      "title": "Binary or Ternary Arithmetic or Logical Operators",
      "category": "code_style",
      "checkType": "regex",
      "description": "이진 연산자(binary operators)와 삼항 연산자(ternary operators), 산술 연산자, 논리 연산자를 사용할 때 연산자의 앞과 뒤에 적어도 하나의 공백을 두어야 합니다. 이는 코드의 가독성을 높이고 표현식의 요소들을 명확히 구분하는 데 도움을 줍니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "\\S[+\\-*/%=<>!&|^]+\\S",
          "flags": "g",
          "description": "연산자 앞뒤에 공백이 없는 경우를 검출"
        },
        {
          "pattern": "\\w(==|!=|<=|>=|&&|\\|\\||\\+=|-=|\\*=|/=|%=)\\w",
          "flags": "g",
          "description": "복합 연산자 앞뒤에 공백이 없는 경우를 검출"
        },
        {
          "pattern": "\\w[+\\-*/%=<>!&|^]\\w",
          "flags": "g",
          "description": "단일 연산자 앞뒤에 공백이 없는 경우를 검출"
        }
      ],
      "customValidator": null,
      "keywords": [
        "Binary",
        "or",
        "Ternary",
        "Arithmetic",
        "Logical",
        "Operators"
      ],
      "examples": {
        "good": [
          "fahren = celsius * 1.8 + 32 ;",
          "xPix = xCoo * xCcale + xAxisPix ;",
          "fahren = celsius * 1.8 + 32;",
          "xPix = xCoo * xScale + xAxisPix;",
          "result = (a > b) ? a : b;"
        ],
        "bad": [
          "fahren=celsius*1.8+32;",
          "xPix=xCoo*xScale+xAxisPix;",
          "result=(a>b)?a:b;",
          "isValid=(x>=0)&&(y<=100);",
          "sum+=value*factor;"
        ]
      },
      "sectionNumber": "3.7.1",
      "businessRules": [
        "이진 연산자나 삼항 연산자 사용 시 연산자 앞뒤에 적어도 하나의 공백을 두어야 한다",
        "산술 연산자나 논리 연산자 사용 시 연산자 앞뒤에 적어도 하나의 공백을 두어야 한다",
        "연산자 주변의 공백은 표현식 요소를 구분하는 역할을 해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "BinaryExpression",
          "AssignmentExpression",
          "LogicalExpression",
          "ConditionalExpression"
        ],
        "checkConditions": [
          "연산자 토큰 앞뒤의 공백 존재 여부 확인",
          "산술 연산자(+, -, *, /, %) 주변 공백 검사",
          "논리 연산자(&&, ||, !) 주변 공백 검사",
          "비교 연산자(==, !=, <, >, <=, >=) 주변 공백 검사",
          "대입 연산자(=, +=, -=, *=, /=) 주변 공백 검사"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_7_2",
      "title": "Unary Arithmetic or Logical Operator 단항 연산자나 논리 연산",
      "category": "code_style",
      "checkType": "regex",
      "description": "단항 연산자(+, -, !, ~, ++, --)와 피연산자 사이에는 공백을 사용하지 않아야 합니다. 단항 연산자는 피연산자에 바로 붙여서 작성해야 합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "([+\\-!~]|\\+\\+|\\-\\-)\\s+([a-zA-Z_$][a-zA-Z0-9_$]*|\\([^)]+\\))",
          "flags": "g",
          "description": "단항 연산자 뒤에 공백이 있는 패턴을 검출"
        }
      ],
      "customValidator": null,
      "keywords": [
        "Unary",
        "Arithmetic",
        "or",
        "Logical",
        "Operator",
        "단항",
        "연산자나",
        "논리",
        "연산"
      ],
      "examples": {
        "good": [
          "inx = - jnx;",
          "newStatus = ! oldStatus;",
          "inx = -jnx;",
          "newStatus = !oldStatus;",
          "count = ++index;"
        ],
        "bad": [
          "inx = - jnx;",
          "newStatus = ! oldStatus;",
          "count = ++ index;",
          "value = ~ mask;",
          "result = + number;"
        ]
      },
      "sectionNumber": "3.7.2",
      "businessRules": [
        "단항 연산자와 피연산자 사이에 공백을 사용하지 않는다",
        "단항 연산자는 피연산자에 바로 붙여서 작성한다"
      ],
      "astHints": {
        "nodeTypes": [
          "UnaryExpression",
          "UpdateExpression"
        ],
        "checkConditions": [
          "단항 연산자와 피연산자 사이의 공백 검사",
          "전위/후위 증감 연산자의 공백 검사"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_7_3",
      "title": "Cast Operator Cast 연산자를 사용할 때에는 공백의 사용을 최소화 해야 한다",
      "category": "code_style",
      "checkType": "regex_with_validation",
      "description": "Cast 연산자 사용 시 공백을 최소화해야 합니다. 타입 지정자는 괄호와 붙여서 작성하고, Cast 연산자와 피연산자 사이에도 공백을 두지 않아야 합니다. 형태: (Type)variable",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "\\(\\s*[A-Z][a-zA-Z0-9<>]*\\s*\\)\\s{2,}[a-zA-Z_]",
          "flags": "g",
          "description": "Cast 연산자 뒤 2칸 이상 공백"
        },
        {
          "pattern": "\\(\\s+[A-Z][a-zA-Z0-9<>]*\\s+\\)\\s*[a-zA-Z_]",
          "flags": "g",
          "description": "Cast 연산자 괄호 내부 공백"
        },
        {
          "pattern": "\\(\\s*[A-Z][a-zA-Z0-9<>]*\\s*\\)\\s+[a-zA-Z_]",
          "flags": "g",
          "description": "Cast 연산자와 피연산자 사이에 공백이 있는 경우를 검출"
        },
        {
          "pattern": "\\(\\s+[A-Z][a-zA-Z0-9<>]*\\s*\\)|\\(\\s*[A-Z][a-zA-Z0-9<>]*\\s+\\)",
          "flags": "g",
          "description": "괄호 내부 타입 지정자 앞뒤에 공백이 있는 경우를 검출"
        }
      ],
      "customValidator": null,
      "keywords": [
        "Cast",
        "Operator",
        "연산자를",
        "사용할",
        "때에는",
        "공백의",
        "사용을",
        "최소화",
        "해야",
        "한다"
      ],
      "examples": {
        "good": [
          "xScale = (float)xCooEnd / xAxisLin ;",
          "xScale = (float)xCooEnd / xAxisLin;",
          "String result = (String)obj;",
          "Integer value = (Integer)data;",
          "Connection conn = (Connection)dataSource;"
        ],
        "bad": [
          "xScale = ( float )xCooEnd / xAxisLin;",
          "xScale = (float) xCooEnd / xAxisLin;",
          "String result = ( String )obj;",
          "String result = (String) obj;",
          "Integer value = ( Integer ) data;"
        ]
      },
      "sectionNumber": "3.7.3",
      "businessRules": [
        "Cast 연산자에서 type specifier는 괄호로부터 분리하여 적지 않아야 한다",
        "Cast 연산자는 제공되는 value로부터 분리되어서는 안 된다",
        "Cast 연산자 사용 시 공백의 사용을 최소화해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "CastExpression",
          "TypeCastExpression"
        ],
        "checkConditions": [
          "Cast 표현식의 타입과 괄호 사이 공백 확인",
          "Cast 연산자와 피연산자 사이 공백 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "Cast 연산자 사용 시",
          "expectedBehavior": "타입 지정자와 괄호 사이, Cast 연산자와 피연산자 사이에 공백이 없어야 함",
          "violationMessage": "Cast 연산자 사용 시 공백을 최소화해야 합니다. 올바른 형태: (Type)variable"
        }
      ]
    },
    {
      "ruleId": "code_style.3_7_4",
      "title": "Comma Operator Comma 연산자 사용 시 , 그 앞에는 공백을 두지 말고 오른",
      "category": "code_style",
      "checkType": "regex",
      "description": "Comma 연산자 사용 시 쉼표(,) 앞에는 공백을 두지 않고, 쉼표 뒤에는 정확히 한 칸의 공백을 둔다. 이는 영문법의 쉼표 사용법과 일치하여 가독성을 향상시킨다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "\\s+,",
          "flags": "g",
          "description": "쉼표 앞에 공백이 있는 경우를 검출 (위반)"
        },
        {
          "pattern": ",(?!\\s)",
          "flags": "g",
          "description": "쉼표 뒤에 공백이 없는 경우를 검출 (위반)"
        },
        {
          "pattern": ",\\s{2,}",
          "flags": "g",
          "description": "쉼표 뒤에 2개 이상의 공백이 있는 경우를 검출 (위반)"
        }
      ],
      "customValidator": null,
      "keywords": [
        "Comma",
        "Operator",
        "연산자",
        "사용",
        "앞에는",
        "공백을",
        "두지",
        "말고",
        "오른"
      ],
      "examples": {
        "good": [
          "inx = 3, jnx = 17 ;",
          "mapPoint( inx , jnx )",
          "for (inx = 3, jnx = 17; inx < X_END; inx++, jnx++) { mapPoint(inx, jnx); }",
          "int a = 1, b = 2, c = 3;",
          "function test(param1, param2, param3) { }"
        ],
        "bad": [
          "for (inx = 3 , jnx = 17; inx < X_END; inx++ , jnx++) { mapPoint(inx , jnx); }",
          "int a = 1 , b = 2 , c = 3;",
          "function test(param1 , param2 , param3) { }",
          "for (inx = 3,jnx = 17; inx < X_END; inx++,jnx++) { }",
          "array[index1,index2,index3]"
        ]
      },
      "sectionNumber": "3.7.4",
      "businessRules": [
        "Comma 연산자 앞에는 공백을 두지 않는다",
        "Comma 연산자 뒤에는 정확히 한 칸의 공백을 둔다",
        "영문법의 쉼표 사용법과 일치하도록 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "ForStatement",
          "SequenceExpression",
          "VariableDeclaration"
        ],
        "checkConditions": [
          "for문의 초기화 부분에서 쉼표 사용",
          "for문의 증감 부분에서 쉼표 사용",
          "변수 선언에서 쉼표 사용",
          "함수 매개변수에서 쉼표 사용"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_7_5",
      "title": "Complete Data References Indexing ( [ ] ) 과 Dot No",
      "category": "code_style",
      "checkType": "regex",
      "description": "배열 인덱싱([])과 점 표기법(.) 연산자는 피연산자와 공백 없이 붙여서 작성해야 합니다. 배열 접근 시 변수명과 대괄호 사이, 객체 속성 접근 시 객체명과 점 사이에 공백이 있으면 안 됩니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "\\w+\\s+\\[",
          "flags": "g",
          "description": "배열 인덱싱 시 변수명과 대괄호 사이의 공백 검출"
        },
        {
          "pattern": "\\]\\s+\\[",
          "flags": "g",
          "description": "다차원 배열 접근 시 대괄호들 사이의 공백 검출"
        },
        {
          "pattern": "\\w+\\s+\\.",
          "flags": "g",
          "description": "점 표기법 사용 시 객체명과 점 사이의 공백 검출"
        },
        {
          "pattern": "\\.\\s+\\w+",
          "flags": "g",
          "description": "점 표기법 사용 시 점과 속성명 사이의 공백 검출"
        }
      ],
      "customValidator": null,
      "keywords": [
        "Complete",
        "Data",
        "References",
        "Indexing",
        "Dot",
        "No"
      ],
      "examples": {
        "good": [
          "initial = midName[0];",
          "accum += test1.samples;",
          "array[i][j] = value;",
          "obj.property.subProperty;",
          "data[key].value;"
        ],
        "bad": [
          "initial = midName [0];",
          "accum += test1 .samples;",
          "array [i] [j] = value;",
          "obj. property.subProperty;",
          "data[key] .value;"
        ]
      },
      "sectionNumber": "3.7.5",
      "businessRules": [
        "배열 인덱싱 연산자([])는 피연산자와 공백 없이 grouping해야 한다",
        "점 표기법 연산자(.)는 피연산자와 공백 없이 grouping해야 한다",
        "배열 접근과 객체 속성 접근 시 연산자와 피연산자 사이에 공백을 두지 않는다"
      ],
      "astHints": {
        "nodeTypes": [
          "MemberExpression",
          "ArrayExpression",
          "CallExpression"
        ],
        "checkConditions": [
          "MemberExpression 노드에서 object와 property 사이 공백 확인",
          "배열 접근 표현식에서 computed property 접근 시 공백 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_7_6",
      "title": "메소드 호출 1) 메소드 이름과 그 뒤의 왼쪽 괄호 사이에는 공백이 없어야 한다 . 2)",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "메소드 호출 시 공백 사용 규칙: 1) 메소드명과 여는 괄호 사이 공백 없음, 2) 인자가 없을 때 괄호 사이 공백 없음, 3) 인자가 있을 때 괄호와 인자 사이 최소 1개 공백, 4) 콤마 앞 공백 없음, 콤마 뒤 최소 1개 공백",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "\\w+\\s+\\(",
          "flags": "g",
          "description": "메소드명과 여는 괄호 사이에 공백이 있는 경우 (위반)"
        },
        {
          "pattern": "\\(\\s+\\)",
          "flags": "g",
          "description": "인자가 없는 메소드 호출에서 괄호 사이에 공백이 있는 경우 (위반)"
        },
        {
          "pattern": "\\([^\\s,)]|[^\\s,(]\\)",
          "flags": "g",
          "description": "인자가 있는 메소드 호출에서 괄호와 인자 사이에 공백이 없는 경우 (위반)"
        },
        {
          "pattern": "\\s+,",
          "flags": "g",
          "description": "콤마 앞에 공백이 있는 경우 (위반)"
        },
        {
          "pattern": ",[^\\s]",
          "flags": "g",
          "description": "콤마 뒤에 공백이 없는 경우 (위반)"
        }
      ],
      "customValidator": null,
      "keywords": [
        "메소드",
        "호출",
        "1)",
        "이름과",
        "뒤의",
        "왼쪽",
        "괄호",
        "사이에는",
        "공백이",
        "없어야"
      ],
      "examples": {
        "good": [
          "choice = getChoice();",
          "getChoice()",
          "println( \"Enter two floating point values: \" )",
          "System.out.println( \"Enter two floating point values:\" );",
          "listMember.setBounds( xPos1, yPos2, xPos1+150, yPos2+250 );"
        ],
        "bad": [
          "choice = getChoice ();",
          "System.out.println( \"Enter two floating point values: \" );",
          "listMember.setBounds(xPos1, yPos2, xPos1+150, yPos2+250);",
          "method( )",
          "calculate(a,b,c)"
        ]
      },
      "sectionNumber": "3.7.6",
      "businessRules": [
        "메소드 이름과 그 뒤의 왼쪽 괄호 사이에는 공백이 없어야 한다",
        "메소드에 전해지는 인자가 없을 때에는 여는 괄호와 닫는 괄호 사이에 공백이 없어야 한다",
        "메소드에 전해지는 인자가 있을 때에는 인자와 앞, 뒤의 괄호 사이에 적어도 하나 이상의 공백이 있어야 한다",
        "메소드에 전달되어지는 인자는 whitespace가 comma에 선행하지 않도록 한다",
        "적어도 하나의 space가 comma 뒤에 올 수 있도록 구성한다"
      ],
      "astHints": {
        "nodeTypes": [
          "MethodInvocation",
          "CallExpression"
        ],
        "checkConditions": [
          "메소드명과 여는 괄호 사이의 공백 검사",
          "인자 개수에 따른 괄호 내부 공백 검사",
          "인자 목록에서 콤마 주변 공백 검사"
        ]
      },
      "contextualChecks": [
        {
          "condition": "메소드 호출 구문 발견",
          "expectedBehavior": "메소드명과 여는 괄호 사이에 공백이 없어야 함",
          "violationMessage": "메소드 이름과 여는 괄호 사이에 공백이 있습니다"
        },
        {
          "condition": "인자가 없는 메소드 호출",
          "expectedBehavior": "여는 괄호와 닫는 괄호 사이에 공백이 없어야 함",
          "violationMessage": "인자가 없는 메소드 호출에서 괄호 사이에 공백이 있습니다"
        },
        {
          "condition": "인자가 있는 메소드 호출",
          "expectedBehavior": "괄호와 인자 사이에 최소 1개의 공백이 있어야 함",
          "violationMessage": "인자와 괄호 사이에 공백이 없습니다"
        },
        {
          "condition": "메소드 인자에 콤마 사용",
          "expectedBehavior": "콤마 앞에는 공백 없음, 콤마 뒤에는 최소 1개 공백",
          "violationMessage": "콤마 주변 공백 규칙을 위반했습니다"
        }
      ]
    },
    {
      "ruleId": "code_style.3_7_7",
      "title": "상수 사용 1) 일반적으로 program documentation 을 향상 시키고 향후 수",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "상수는 static final 키워드를 사용하여 선언해야 하며, 의미가 분명하고 프로그램 실행 중 값이 변하지 않는 경우에만 사용해야 합니다. 상수명은 대문자와 언더스코어로 구성되어야 합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "static\\s+final\\s+[A-Z_][A-Z0-9_]*\\s*=",
          "flags": "g",
          "description": "static final 상수 선언 패턴"
        },
        {
          "pattern": "[A-Z][A-Z0-9_]*",
          "flags": "g",
          "description": "상수명 명명 규칙 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "상수",
        "사용",
        "1)",
        "일반적으로",
        "program",
        "documentation",
        "향상",
        "시키고",
        "향후"
      ],
      "examples": {
        "good": [
          "public static final int MAX_SIZE = 100;",
          "private static final String DATABASE_URL = \"jdbc:mysql://localhost:3306/db\";",
          "public static final double PI = 3.14159;",
          "private static final int DEFAULT_TIMEOUT = 30000;"
        ],
        "bad": [
          "public final int maxSize = 100; // static 키워드 누락",
          "public static int MAX_SIZE = 100; // final 키워드 누락",
          "public static final int maxSize = 100; // 소문자 사용",
          "public static final int MAX-SIZE = 100; // 하이픈 사용",
          "if (count > 100) { ... } // 매직 넘버 사용"
        ]
      },
      "sectionNumber": "3.7.7",
      "businessRules": [
        "상수는 static final 키워드를 사용하여 선언해야 한다",
        "상수는 프로그램 문서화를 향상시키고 향후 값 변경을 용이하게 해야 한다",
        "상수는 의미가 분명하고 충분히 읽기 쉬운 경우에만 사용해야 한다",
        "상수는 프로그램 실행 중 값이 변하지 않을 것 같은 경우에만 사용해야 한다",
        "상수명은 대문자와 언더스코어로 구성되어야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "FieldDeclaration",
          "VariableDeclarator"
        ],
        "checkConditions": [
          "필드가 static final 키워드를 모두 포함하는지 확인",
          "상수명이 대문자와 언더스코어로만 구성되었는지 확인",
          "상수에 초기값이 할당되었는지 확인",
          "매직 넘버나 하드코딩된 문자열이 상수로 선언되었는지 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "필드 선언에서 static final 키워드가 모두 사용되었는지 확인",
          "expectedBehavior": "상수는 반드시 static final로 선언되어야 함",
          "violationMessage": "상수는 static final 키워드를 사용하여 선언해야 합니다"
        },
        {
          "condition": "상수명이 대문자와 언더스코어로만 구성되었는지 확인",
          "expectedBehavior": "상수명은 UPPER_CASE 형태로 작성되어야 함",
          "violationMessage": "상수명은 대문자와 언더스코어로만 구성되어야 합니다"
        },
        {
          "condition": "코드 내 매직 넘버나 하드코딩된 문자열이 상수로 선언되었는지 확인",
          "expectedBehavior": "반복 사용되는 리터럴 값은 상수로 선언되어야 함",
          "violationMessage": "매직 넘버나 하드코딩된 문자열은 상수로 선언하여 사용해야 합니다"
        }
      ]
    },
    {
      "ruleId": "code_style.3_3_8",
      "title": "기타 1) 하나의 expression 에는 오직 하나의 할당 연산자를 사용한다 . 아래와",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "하나의 표현식(expression)에는 오직 하나의 할당 연산자만 사용해야 하며, 논리연산 단일 표현에서 논리 AND 또는 논리 OR 연산자를 2개 이상 사용하지 않아야 한다. NOT 연산자는 코드 가독성을 해치지 않을 때만 사용한다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "\\w+\\s*=\\s*\\w+\\s*=",
          "flags": "g",
          "description": "연쇄 할당 연산자 패턴 (a = b = 2)"
        },
        {
          "pattern": "\\([^)]*=.*\\)\\s*[+\\-*/]\\s*\\([^)]*=.*\\)",
          "flags": "g",
          "description": "표현식 내 다중 할당 패턴"
        },
        {
          "pattern": "&&.*&&|\\|\\|.*\\|\\|",
          "flags": "g",
          "description": "논리 연산자 2개 이상 사용 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "기타",
        "1)",
        "하나의",
        "expression",
        "에는",
        "오직",
        "할당",
        "연산자를",
        "사용한다",
        "아래와"
      ],
      "examples": {
        "good": [
          "a = b = 2;",
          "method1()",
          "method2()",
          "a = 2;\nb = 2;",
          "if (x == 10 && y == 20) { }"
        ],
        "bad": [
          "a = b = 2;",
          "if (((x = method1()) + (y = method2())) == 10) { }",
          "if (condition1 && condition2 && condition3) { }",
          "if (condition1 || condition2 || condition3) { }",
          "if (!(condition1 && condition2 && !condition3)) { }"
        ]
      },
      "sectionNumber": "3.3.8",
      "businessRules": [
        "하나의 expression에는 오직 하나의 할당 연산자를 사용해야 한다",
        "논리연산 단일 표현에서 논리 AND 또는 논리 OR 연산자를 2개 이상 사용하지 않아야 한다",
        "NOT 연산자는 코드 가독성을 해치지 않을 때만 사용해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "AssignmentExpression",
          "BinaryExpression",
          "UnaryExpression",
          "IfStatement",
          "ConditionalExpression"
        ],
        "checkConditions": [
          "단일 표현식 내에서 할당 연산자(=) 개수가 1개를 초과하는지 확인",
          "논리 AND(&&) 또는 논리 OR(||) 연산자가 같은 표현식에서 2개 이상 사용되는지 확인",
          "NOT(!) 연산자 사용 시 가독성을 해치는 복잡한 구조인지 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "단일 표현식에서 할당 연산자가 2개 이상 사용됨",
          "expectedBehavior": "각 할당을 별도의 문장으로 분리",
          "violationMessage": "하나의 표현식에는 오직 하나의 할당 연산자만 사용해야 합니다"
        },
        {
          "condition": "논리 AND 또는 OR 연산자가 같은 표현식에서 2개 이상 사용됨",
          "expectedBehavior": "복잡한 논리식을 여러 단계로 분리하거나 메서드로 추출",
          "violationMessage": "논리연산 단일 표현에서 논리 AND 또는 논리 OR 연산자를 2개 이상 사용하지 마세요"
        },
        {
          "condition": "NOT 연산자가 복잡한 논리식과 함께 사용되어 가독성을 해침",
          "expectedBehavior": "논리식을 단순화하거나 긍정적 조건으로 변경",
          "violationMessage": "NOT 연산자는 코드 가독성을 해치지 않을 때만 사용하세요"
        }
      ]
    }
  ]
}