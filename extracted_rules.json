{
  "metadata": {
    "extractedAt": "2025-10-15T00:57:25.693Z",
    "totalRules": 42,
    "version": "4.0.0-llm",
    "extractor": "llm-enhanced-parser",
    "llmEnabled": true
  },
  "guidelines": [
    {
      "ruleId": "naming_convention.2_1",
      "title": "서비스 ID 업무코드",
      "category": "naming_convention",
      "checkType": "regex",
      "description": "서비스 ID 업무코드는 11자리로 구성되며, 각 구성 요소는 다음과 같은 형식을 따른다: 3자리 서비스 ID + 2자리 업무구분 + 4자리 일련번호 + 1자리 기능분류 + 1자리 세분류 일련번호",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^[0-9]{3}[0-9]{2}[0-9]{4}[0-2][1-9A-Z]$",
          "flags": "g",
          "description": "11자리 서비스 ID 업무코드 형식"
        }
      ],
      "customValidator": null,
      "keywords": [
        "서비스",
        "ID",
        "업무코드"
      ],
      "examples": {
        "good": [
          "SVC00101000101A",
          "SVC00202000202B"
        ],
        "bad": [
          "SVC00101000101",
          "SVC0010100010101",
          "SVC0010100010100"
        ]
      },
      "sectionNumber": "2.1",
      "businessRules": [
        "서비스 ID 업무코드는 11자리로 구성되어야 한다",
        "업무구분 코드는 2자리여야 하며, 숫자로 구성되어야 한다",
        "일련번호는 4자리여야 하며, 숫자로 구성되어야 한다",
        "기능분류는 1자리여야 하며, 0, 1, 2 중 하나여야 한다",
        "세분류 일련번호는 1자리여야 하며, 1~9 또는 A~Z 중 하나여야 한다"
      ],
      "astHints": {},
      "contextualChecks": []
    },
    {
      "ruleId": "naming_convention.2_3_1",
      "title": "JOB ID 업무코드",
      "category": "naming_convention",
      "checkType": "regex_with_validation",
      "description": "JOB ID는 업무코드(3자리) + 주기(1자리) + 배치유형(1자리) + 일련번호(4자리)로 구성되며, 각 구성 요소는 정해진 규칙에 따라야 한다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "3 자리",
          "flags": "g"
        },
        {
          "pattern": "1 자리",
          "flags": "g"
        },
        {
          "pattern": "1 자리",
          "flags": "g"
        },
        {
          "pattern": "4 자리",
          "flags": "g"
        },
        {
          "pattern": "^[A-Z]{3}[DWMQHYOAS][BSD][0-9]{4}$",
          "flags": "g",
          "description": "JOB ID 형식에 맞는 정규식"
        }
      ],
      "customValidator": null,
      "keywords": [
        "JOB",
        "ID",
        "업무코드",
        "DB"
      ],
      "examples": {
        "good": [
          "IFWDB0001 항목 길이 설명 업무코드 3 업무구분코드 2Level 주기 1 D : Daily W : Weekly M : Monthly Q : Quaterly H : Half Y : Yearly O : Online A : At Any Time( 수시 ) 배치유형 1",
          "Time( 수시 )",
          "SP(stored procedure)",
          "IFWDB0001",
          "ABCWSD0001"
        ],
        "bad": [
          "IFWDB00012",
          "ABCWSD000"
        ]
      },
      "sectionNumber": "2.3.1",
      "businessRules": [
        "JOB ID는 9자리의 고정 길이 문자열이어야 한다.",
        "업무코드는 3자리의 알파벳으로 구성되어야 한다.",
        "주기는 D(일), W(주), M(월), Q(분기), H(반기), Y(년), O(온라인), A(수시) 중 하나여야 한다.",
        "배치유형은 B(일반), S(SP), D(후행) 중 하나여야 한다.",
        "일련번호는 4자리의 숫자로 구성되어야 한다."
      ],
      "astHints": {
        "nodeTypes": [],
        "checkConditions": []
      },
      "contextualChecks": []
    },
    {
      "ruleId": "naming_convention.2_3_2",
      "title": "STEP ID 배치 JOB ID(9 자리 ) + STEP 일련번호",
      "category": "naming_convention",
      "checkType": "static_analysis",
      "description": "STEP ID 형식: 업무코드(3자리) + 주기(1자리) + 배치유형(1자리) + 일련번호(4자리) + STEP 일련번호(2자리)",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "9 자리",
          "flags": "g"
        },
        {
          "pattern": "2 자리",
          "flags": "g"
        },
        {
          "pattern": "3 자리",
          "flags": "g"
        },
        {
          "pattern": "1 자리",
          "flags": "g"
        },
        {
          "pattern": "1 자리",
          "flags": "g"
        }
      ],
      "customValidator": null,
      "keywords": [
        "STEP",
        "ID",
        "배치",
        "JOB",
        "ID(9",
        "자리",
        "일련번호",
        "DB"
      ],
      "examples": {
        "good": [
          "IFWDB000101 항목 길이 설명 JOB ID 9 업무코드 (3 자리 ) + 주기 (1 자리 ) + 배치유형 (1 자리 ) + 일 련번호 (4 자리 ) STEP 일련번호 2 스텝 일련번호 , 01~99",
          "ID(9 자리 )"
        ],
        "bad": []
      },
      "sectionNumber": "2.3.2",
      "businessRules": [],
      "astHints": {},
      "contextualChecks": []
    },
    {
      "ruleId": "naming_convention.2_4_1",
      "title": "input 파일명 - 배치 step ID",
      "category": "naming_convention",
      "checkType": "regex_with_validation",
      "description": "배치 STEP ID에 따라 명명된 input 파일명 규칙을 검사합니다. 파일명은 STEP ID + '.' + 식별번호로 구성되며, 식별번호는 01~99 사이의 숫자여야 합니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^[A-Z0-9]+\\.[0-9]{2}$",
          "flags": "g",
          "description": "STEP ID(1~11자리) + '.' + 식별번호(2자리 숫자) 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "input",
        "파일명",
        "배치",
        "step",
        "ID",
        "DB"
      ],
      "examples": {
        "good": [
          "ID( 1 1 )",
          "IFWDB000101",
          "IFWDB000101.01",
          "IFWDB000101.02"
        ],
        "bad": [
          "IFWDB000101.00",
          "IFWDB000101.100",
          "IFWDB000101.1"
        ]
      },
      "sectionNumber": "2.4.1",
      "businessRules": [
        "배치 STEP ID는 1~11자리의 문자열이어야 합니다.",
        "파일명은 STEP ID + '.' + 식별번호로 구성되어야 합니다.",
        "식별번호는 01~99 사이의 숫자여야 합니다.",
        "파일명은 대소문자를 구분합니다.",
        "다른 STEP의 output을 input으로 사용할 경우 원래의 output 파일명을 사용해야 합니다."
      ],
      "astHints": {},
      "contextualChecks": []
    },
    {
      "ruleId": "naming_convention.2_4_2",
      "title": "output 파일명 - 배치 step ID",
      "category": "naming_convention",
      "checkType": "regex_with_validation",
      "description": "배치 step ID에 따른 output 파일명 명명 규칙을 검사합니다. 파일명은 STEP ID + '.' + 식별번호 + '.' + ODATE 형식을 따릅니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^[A-Z0-9]{11}\\.(\\d{2})\\.(\\d{8})$",
          "flags": "g",
          "description": "STEP ID(11자리) + '.' + 식별번호(2자리) + '.' + ODATE(8자리) 형식"
        }
      ],
      "customValidator": null,
      "keywords": [
        "output",
        "파일명",
        "배치",
        "step",
        "ID",
        "DB"
      ],
      "examples": {
        "good": [
          "ID(1 1 )",
          "IFWDB000101.01.20120712",
          "IFWDB000101.02.20120712"
        ],
        "bad": [
          "IFWDB000101.1.20120712",
          "IFWDB000101.01.120712"
        ]
      },
      "sectionNumber": "2.4.2",
      "businessRules": [
        "배치 step ID는 11자리여야 합니다.",
        "식별번호는 01~99 사이의 숫자여야 합니다.",
        "ODATE는 8자리의 YYYYMMDD 형식이어야 합니다.",
        "파일명은 STEP ID + '.' + 식별번호 + '.' + ODATE 형식을 따라야 합니다.",
        "파일명은 반드시 배치 step ID로 시작해야 합니다.",
        "파일명은 반드시 ODATE 형식을 따라야 합니다."
      ],
      "astHints": {
        "nodeTypes": [],
        "checkConditions": []
      },
      "contextualChecks": []
    },
    {
      "ruleId": "naming_convention.2_4_3",
      "title": "파일 IO spec ID 배치 Step ID",
      "category": "naming_convention",
      "checkType": "regex_with_validation",
      "description": "파일 I/O Spec ID는 STEP ID(11자리) + 일련번호(2자리) + '_' + I/O 구분(1자리)으로 구성되며, 대문자로 등록해야 한다. Input과 Output은 별도로 구분하여 등록해야 한다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "1 자리",
          "flags": "g"
        },
        {
          "pattern": "2 자리",
          "flags": "g"
        },
        {
          "pattern": "^[A-Z0-9]{11}[0-9]{2}_[IO]$",
          "flags": "g",
          "description": "STEP ID(11자리) + 일련번호(2자리) + '_' + I/O 구분(1자리) 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "파일",
        "IO",
        "spec",
        "ID",
        "배치",
        "Step",
        "DB"
      ],
      "examples": {
        "good": [
          "ID(1 1 )",
          "Output(O)",
          "IFWDB000101_01_I",
          "IFWDB000101_01_O"
        ],
        "bad": [
          "ifwdb000101_01_i",
          "IFWDB000101_1_I",
          "IFWDB000101_01_X"
        ]
      },
      "sectionNumber": "2.4.3",
      "businessRules": [
        "파일 I/O Spec ID는 대문자로 등록해야 한다",
        "같은 파일에 대한 Input과 Output은 별도로 등록해야 한다",
        "STEP ID는 11자리여야 하며, 일련번호는 2자리여야 한다",
        "I/O 구분은 'I' 또는 'O'여야 한다"
      ],
      "astHints": {},
      "contextualChecks": []
    },
    {
      "ruleId": "naming_convention.2_6",
      "title": "클래스 클래스의 이름은 명사여야 하고 , 첫 문자를 대문자로 한다 중간에 의미 있는 단어가",
      "category": "naming_convention",
      "checkType": "regex_with_validation",
      "description": "클래스 이름은 명사여야 하며 PascalCase 표기법을 사용해야 하며, 단어는 메타시스템에 정의되어 있는 단어를 사용해야 한다. 클래스 이름은 접미어를 포함해야 하며, 접미어는 클래스의 기능에 따라 정해진 규칙에 따라 붙여야 한다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^[A-Z][a-zA-Z0-9]*[A-Z][a-zA-Z0-9]*$",
          "flags": "g",
          "description": "PascalCase 형식의 클래스 이름 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "클래스",
        "클래스의",
        "이름은",
        "명사여야",
        "하고",
        "문자를",
        "대문자로",
        "한다",
        "중간에",
        "의미"
      ],
      "examples": {
        "good": [
          "BrnInfoOfrCpbc",
          "CenterCutPre",
          "CenterCutPost"
        ],
        "bad": [
          "brnInfoOfrCpbc",
          "centerCutPre",
          "BrnInfoOfrCpbcPre"
        ]
      },
      "sectionNumber": "2.6",
      "businessRules": [
        "클래스 이름은 명사여야 한다",
        "클래스 이름은 PascalCase 표기법을 사용해야 한다",
        "클래스 이름은 메타시스템에 정의되어 있는 단어를 사용해야 한다",
        "클래스 이름은 접미어를 포함해야 한다",
        "접미어는 클래스의 기능에 따라 정해진 규칙에 따라 붙여야 한다"
      ],
      "astHints": {
        "nodeTypes": [],
        "checkConditions": []
      },
      "contextualChecks": []
    },
    {
      "ruleId": "naming_convention.2_7",
      "title": "메소드 메소드의 이름은 동사여야 하고 , 첫 문자는 소문자이며 , 동사사전 ( 모델링 )",
      "category": "naming_convention",
      "checkType": "regex_with_validation",
      "description": "메소드 이름은 동사로 시작해야 하며, 첫 글자는 소문자, CamelCase 표기법을 따르며, 단어는 메타 시스템에 등록된 표준항목 또는 표준단어의 조합으로 작성되어야 한다. 메소드 이름은 동사사전에 정의된 단어로 시작해야 하며, 중간에 의미 있는 단어가 나올 경우 그 단어의 첫 글자는 대문자로 한다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^[a-z][a-zA-Z0-9]*$",
          "flags": "g",
          "description": "CamelCase 형식의 메소드 이름 패턴 (첫 글자 소문자, 이후 알파벳 또는 숫자)"
        }
      ],
      "customValidator": null,
      "keywords": [
        "메소드",
        "메소드의",
        "이름은",
        "동사여야",
        "하고",
        "문자는",
        "소문자이며",
        "동사사전",
        "모델링",
        "Exception"
      ],
      "examples": {
        "good": [
          "public LData r",
          "retrieveLastTrstNoGvno(LData gvnoInqTrmsEBI)",
          "public LData retrieveLastTrstNoGvno(LData gvnoInqTrmsEBI) throws LException",
          "public String getUserName(String userId) throws Exception"
        ],
        "bad": [
          "public LData RetrieveLastTrstNoGvno(LData gvnoInqTrmsEBI) throws LException",
          "public LData get_last_trst_no_gvno(LData gvnoInqTrmsEBI) throws LException"
        ]
      },
      "sectionNumber": "2.7",
      "businessRules": [
        "메소드 이름은 동사여야 한다",
        "메소드 이름의 첫 글자는 소문자여야 한다",
        "메소드 이름은 CamelCase 표기법을 따른다",
        "메소드 이름은 동사사전에 정의된 단어로 시작해야 한다",
        "중간에 의미 있는 단어가 나올 경우 그 단어의 첫 글자는 대문자로 한다",
        "단어는 메타 시스템에 등록되어 있는 표준항목 또는 표준단어의 조합으로 작성되어야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "MethodDeclaration"
        ],
        "checkConditions": [
          "MethodDeclaration 노드의 name 속성 검증",
          "메소드 이름이 CamelCase 형식인지 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "LData의 Key는 DB column명을 소문자로 변환하여 저장한다",
          "expectedBehavior": "LData의 키 값은 소문자로 변환되어야 한다",
          "violationMessage": "LData의 키는 DB column명을 소문자로 변환하여 저장해야 합니다"
        }
      ]
    },
    {
      "ruleId": "naming_convention.2_8",
      "title": "로컬변수 변수는 소문자만을 사용 하며 , 변수명명규칙에 따라 단어 또는 복합단어로 사용한다",
      "category": "naming_convention",
      "checkType": "regex_with_validation",
      "description": "로컬변수는 소문자로 시작하며, CamelCase 표기법을 따르며, 타입 약어를 앞에 붙여야 한다. 타입 약어는 String(s), Boolean(b), BigDecimal(bd), Long(l), Integer(it), DTO(t) 등이 있다. 또한, LData 타입의 변수는 DB column명을 소문자로 변환하여 저장해야 한다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^([sb]|(bd)|(l)|(it)|(t)|(i)|(r))([a-z][a-zA-Z0-9]*)$",
          "flags": "g",
          "description": "타입 약어 + CamelCase 변수명 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "로컬변수",
        "변수는",
        "소문자만을",
        "사용",
        "하며",
        "변수명명규칙에",
        "따라",
        "단어",
        "또는",
        "복합단어로"
      ],
      "examples": {
        "good": [
          "aging = new LData();",
          "LData()",
          "String sName = \"test\";",
          "BigDecimal bdAccount = new BigDecimal(\"1000\");",
          "LData tPaging = new LData();"
        ],
        "bad": [
          "String Name = \"test\";",
          "BigDecimal BD_ACCOUNT = new BigDecimal(\"1000\");",
          "LData TPaging = new LData();"
        ]
      },
      "sectionNumber": "2.8",
      "businessRules": [
        "로컬변수는 소문자로 시작해야 한다",
        "로컬변수는 CamelCase 표기법을 따라야 한다",
        "로컬변수는 타입 약어를 앞에 붙여야 한다",
        "LData 타입의 변수는 DB column명을 소문자로 변환하여 저장해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "VariableDeclarator"
        ],
        "checkConditions": [
          "변수 선언문에서 타입 약어와 CamelCase 변수명 검증"
        ]
      },
      "contextualChecks": [
        {
          "condition": "LData 타입 변수 선언 시 DB column명 소문자 변환 여부",
          "expectedBehavior": "변수명이 DB column명을 소문자로 변환한 형태여야 한다",
          "violationMessage": "LData 타입 변수는 DB column명을 소문자로 변환하여 저장해야 합니다."
        }
      ]
    },
    {
      "ruleId": "naming_convention.2_9",
      "title": "상수 클래스 상수로 선언된 변수의 이름은 모두 대문자를 사용하고 , 의미 있는 단어가 나올",
      "category": "naming_convention",
      "checkType": "static_analysis",
      "description": "주의 ) 상수는 공통에서만 사용하며 , 일반 업무 클래스에서는 상수를 사용하지 않도록 한다",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "상수",
        "클래스",
        "상수로",
        "선언된",
        "변수의",
        "이름은",
        "모두",
        "대문자를",
        "사용하고",
        "의미"
      ],
      "examples": {
        "good": [
          "MIN_WIDTH = 4;"
        ],
        "bad": []
      },
      "sectionNumber": "2.9",
      "businessRules": [],
      "astHints": {
        "nodeTypes": [
          "FieldDeclaration",
          "VariableDeclarator"
        ],
        "checkConditions": [
          "static final 변수의 이름이 대문자로 시작하고 밑줄을 포함하는지 검사"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "naming_convention.2_10",
      "title": "입력 파라미터 메소드의 입력 파라미터의 이름은 로컬변수 명명규칙과 동일하게 사용한다 . -",
      "category": "naming_convention",
      "checkType": "regex",
      "description": "입력 파라미터 메소드의 입력 파라미터 이름은 로컬변수 명명규칙과 동일하게 사용해야 한다. 즉, camelCase 표기법을 사용해야 하며, 첫 글자는 소문자로 시작해야 한다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^([a-z][a-zA-Z0-9]*)$",
          "flags": "g",
          "description": "camelCase 표기법을 따르는 변수명 패턴 (첫 글자는 소문자, 이후는 대소문자 및 숫자 가능)"
        }
      ],
      "customValidator": null,
      "keywords": [
        "입력",
        "파라미터",
        "메소드의",
        "파라미터의",
        "이름은",
        "로컬변수",
        "명명규칙과",
        "동일하게",
        "사용한다",
        "Exception"
      ],
      "examples": {
        "good": [
          "public LMultiData r",
          "public void r",
          "public LMultiData retrieveList(LData listInqTrms) throws LException",
          "public void regist(String regIstm) throws LException"
        ],
        "bad": [
          "public LMultiData retrieveList(LData ListInqTrms) throws LException",
          "public void regist(String REGIST_ISTM) throws LException"
        ]
      },
      "sectionNumber": "2.10",
      "businessRules": [
        "입력 파라미터의 이름은 로컬변수 명명규칙과 동일하게 사용해야 한다",
        "입력 파라미터 이름은 camelCase 표기법을 사용해야 한다",
        "입력 파라미터 이름의 첫 글자는 소문자로 시작해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "MethodDeclaration",
          "VariableDeclarator"
        ],
        "checkConditions": [
          "MethodDeclaration 내의 ParameterDeclarator의 변수명이 camelCase 규칙을 따르는지 검사",
          "VariableDeclarator의 변수명이 camelCase 규칙을 따르는지 검사"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "naming_convention.2_11",
      "title": "Exception try~catch() 구문에서 catch 문 내에 Exception 에",
      "category": "naming_convention",
      "checkType": "regex",
      "description": "try~catch 구문 내의 catch 블록에서 Exception 변수명은 특정 Exception 타입에 따라 명명 규칙을 따라야 한다. LBizException은 lbe, DevonException은 de, LInterfaceException은 lie, LDuplicateException은 lde로 명명해야 한다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "\\b(LBizException|DevonException|LInterfaceException|LDuplicateException)\\s+(\\w+)\\s*\\(",
          "flags": "g",
          "description": "Exception 타입과 변수명을 함께 검사하는 정규식"
        }
      ],
      "customValidator": null,
      "keywords": [
        "Exception",
        "try~catch()",
        "구문에서",
        "catch",
        "내에",
        "변수"
      ],
      "examples": {
        "good": [
          "catch()",
          "try { ... } catch (LBizException lbe) { ... }",
          "try { ... } catch (DevonException de) { ... }",
          "try { ... } catch (LInterfaceException lie) { ... }",
          "try { ... } catch (LDuplicateException lde) { ... }"
        ],
        "bad": [
          "try { ... } catch (LBizException exception) { ... }",
          "try { ... } catch (DevonException e) { ... }",
          "try { ... } catch (LInterfaceException ex) { ... }",
          "try { ... } catch (LDuplicateException exception) { ... }"
        ]
      },
      "sectionNumber": "2.11",
      "businessRules": [
        "Exception 변수명은 Exception 타입에 따라 명명 규칙을 따라야 한다",
        "LBizException은 lbe로 명명해야 한다",
        "DevonException은 de로 명명해야 한다",
        "LInterfaceException은 lie로 명명해야 한다",
        "LDuplicateException은 lde로 명명해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "CatchClause",
          "VariableDeclarator"
        ],
        "checkConditions": [
          "catch 블록 내에서 Exception 변수명이 규칙에 맞는지 검사",
          "Exception 타입이 지정된 타입인지 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "naming_convention.2_12",
      "title": "LData / LMultiData DB 의 테이블과 연관있는 LData/LMultiData",
      "category": "naming_convention",
      "checkType": "llm_contextual",
      "description": "LData 또는 LMultiData의 Key는 DB 컬럼명을 소문자로 변환하여 저장해야 한다. 이는 쿼리 결과와 입력 파라미터의 일관성을 유지하기 위한 규칙이다.",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "LData",
        "LMultiData",
        "DB",
        "테이블과",
        "연관있는",
        "ResultSet",
        "column"
      ],
      "examples": {
        "good": [
          "LData data = new LData();\ndata.put(\"reg_date\", value);",
          "LMultiData multiData = new LMultiData();\nmultiData.put(\"reg_date\", resultSet);"
        ],
        "bad": [
          "LData data = new LData();\ndata.put(\"REG_DATE\", value);",
          "LMultiData multiData = new LMultiData();\nmultiData.put(\"RegDate\", resultSet);"
        ]
      },
      "sectionNumber": "2.12",
      "businessRules": [
        "LData의 Key는 DB 컬럼명을 소문자로 변환하여 저장해야 한다.",
        "LMultiData의 Key는 DB column명을 소문자로 변환하여 저장해야 한다."
      ],
      "astHints": {
        "nodeTypes": [],
        "checkConditions": []
      },
      "contextualChecks": [
        {
          "condition": "LData 또는 LMultiData의 Key가 DB 컬럼명을 소문자로 변환하지 않은 경우",
          "expectedBehavior": "Key는 DB 컬럼명을 소문자로 변환해야 한다",
          "violationMessage": "LData/LMultiData의 Key는 DB 컬럼명을 소문자로 변환하여 저장해야 합니다."
        }
      ]
    },
    {
      "ruleId": "code_style.3_1_1",
      "title": "일반적 규칙 1) 프로그램 내에서 지정된 것으로서의 들여쓰기를 제외한다면 , source",
      "category": "code_style",
      "checkType": "regex_with_validation",
      "description": "C 언어 스타일의 코드 포맷팅 규칙을 적용합니다. 들여쓰기는 4칸 공백을 사용하고, 줄 길이는 100자 이내로 유지하며, 연산자와 예약어 뒤에는 공백을 두어야 합니다.",
      "severity": "HIGH",
      "patterns": [
        {
          "pattern": "\\(\\s*[A-Z][a-zA-Z0-9<>]*\\s*\\)\\s{2,}[a-zA-Z_]",
          "flags": "g",
          "description": "Cast 연산자 뒤 2칸 이상 공백"
        },
        {
          "pattern": "\\(\\s+[A-Z][a-zA-Z0-9<>]*\\s+\\)\\s*[a-zA-Z_]",
          "flags": "g",
          "description": "Cast 연산자 괄호 내부 공백"
        },
        {
          "pattern": "^\\s*\\w+\\s+\\w+\\s*\\(",
          "flags": "g",
          "description": "예약어 다음에 공백이 있는지 확인"
        },
        {
          "pattern": "\\s+\\*\\s+",
          "flags": "g",
          "description": "포인터 선언 시 * 앞뒤 공백이 없는지 확인"
        }
      ],
      "customValidator": null,
      "keywords": [
        "일반적",
        "규칙",
        "1)",
        "프로그램",
        "내에서",
        "지정된",
        "것으로서의",
        "들여쓰기를",
        "제외한다면",
        "source"
      ],
      "examples": {
        "good": [
          "result = (a * (b + c + d) * (e + f)); 9) Unary 연산은 space 를 두지 않는다 . 10) Cast Operator 는 괄호 전후에 space 를 두지 않는다 . 11) [], ., - >, &, * 에는 space 를 두지 않는다",
          "result = (a * (b + c + d) * (e + f));",
          "Semicolon(;)",
          "comma(,)",
          "int a = 10;"
        ],
        "bad": [
          "int a=10;",
          "int * ptr = &a;"
        ]
      },
      "sectionNumber": "3.1.1",
      "businessRules": [
        "프로그램 내에서 지정된 것으로서의 들여쓰기를 제외한다면, source code는 공백 없이 첫 번째 column에서 시작한다.",
        "한 라인의 Column의 크기는 가급적 100 Characters를 넘지 않게 각 프로젝트의 표준에 따라 정하도록 한다.",
        "모든 indentation은 4칸이며 반드시 space를 사용하도록 한다.",
        "가급적이면 한 줄에 하나의 statement만 기술한다.",
        "예약어(Rreserved Word) 다음에는 반드시 space를 둔다.",
        "Operator 앞뒤에는 space를 둔다.",
        "Semicolon(;), comma(,) 사용 시 뒤에 space를 둔다.",
        "중첩된 괄호로 연결한 표현식일 경우 괄호사이에 공백을 두지 않는다.",
        "Unary 연산은 space를 두지 않는다.",
        "Cast Operator는 괄호 전후에 space를 두지 않는다.",
        "[], ., ->, &, *에는 space를 두지 않는다.",
        "논리연산자 전후로 space를 둔다."
      ],
      "astHints": {
        "nodeTypes": [
          "VariableDeclaration",
          "ExpressionStatement"
        ],
        "checkConditions": [
          "변수 선언문과 표현식 문장에서 공백 규칙 검사"
        ]
      },
      "contextualChecks": [
        {
          "condition": "LData의 Key는 DB column명을 소문자로 변환하여 저장한다",
          "expectedBehavior": "DB column명을 소문자로 변환하여 저장",
          "violationMessage": "LData의 Key는 DB column명을 소문자로 변환하여 저장해야 합니다."
        }
      ]
    },
    {
      "ruleId": "code_style.3_1_2",
      "title": "줄 나누기 한 행에 모두 기술하지 못할 경우 행을 나누는 규칙은 다음과 같다 1) 콤마",
      "category": "code_style",
      "checkType": "regex_with_validation",
      "description": "줄 나누기 규칙은 콤마 뒤, 연산자 앞, 그리고 높은 단계에서 나누며, 같은 단계의 줄은 위의 줄과 같은 컬럼에 위치해야 한다. 또한, 긴 문자열 연결은 StringBuffer를 사용해야 하며, '+' 연산자를 사용해서 연결하지 않도록 한다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "\\+\\s*\\+",
          "flags": "g",
          "description": "String 연결 시 '+' 연산자를 사용하는 경우"
        }
      ],
      "customValidator": null,
      "keywords": [
        "나누기",
        "행에",
        "모두",
        "기술하지",
        "못할",
        "경우",
        "행을",
        "나누는",
        "규칙은",
        "다음과"
      ],
      "examples": {
        "good": [
          "sql1 = new StringBuffer( “SELECT COLUMN1, COLUMN2, COLUMN3, COLUMN4” );",
          "COLUMN1 = ‘ ” + VALUE1 + “’” );",
          "public DamageInfo g",
          "StringBuffer( “SELECT COLUMN1, COLUMN2, COLUMN3, COLUMN4” )",
          "append( “FROM TABLE1, TABLE2, TABLE3” )"
        ],
        "bad": [
          "public DamageInfo getDamageDetail(String pDisasterMgmtNo, String pOccurAddrCode, String pDmgCauseCode, Connection pConn) throws SQLException, InformException {\n    String sql = \"SELECT COLUMN1, COLUMN2, COLUMN3, COLUMN4\" + \n                 \"FROM TABLE1, TABLE2, TABLE3\" + \n                 \"WHERE COLUMN1 = '\" + VALUE1 + \"'\" + \n                 \"AND COLUMN2 = `\" + VALUE2 + \"'\" + \n                 \"ORDER BY COLUMN1\";\n}",
          "if ((condition1 && condition2) || (condition3 && condition4) || !(condition5 && condition6)) {\n    doSomethingAboutIt();\n}"
        ]
      },
      "sectionNumber": "3.1.2",
      "businessRules": [
        "한 행에 모두 기술하지 못할 경우 행을 나누는 규칙은 콤마 뒤에서 나눈다",
        "한 행에 모두 기술하지 못할 경우 행을 나누는 규칙은 연산자 앞에서 나눈다",
        "한 행에 모두 기술하지 못할 경우 행을 나누는 규칙은 높은 단계에서 나눈다",
        "나누어진 줄이 같은 단계라면 위의 줄과 같은 컬럼에 위치시킨다",
        "긴 String 연결은 StringBuffer Class 를 이용한다",
        "긴 String 연결 시 연결연산자 (+) 를 사용해서 연결하지 않도록 한다",
        "조건이 복잡한 비교 문장은 적당한 조건단위로 나누어 여러 줄에 사용한다"
      ],
      "astHints": {
        "nodeTypes": [
          "MethodDeclaration",
          "VariableDeclarator",
          "ExpressionStatement",
          "BinaryExpression"
        ],
        "checkConditions": [
          "MethodDeclaration에서 파라미터가 여러 개일 경우 한 줄에 하나씩 여러 줄에 기입하는지 확인",
          "VariableDeclarator에서 StringBuffer 사용 여부 확인",
          "BinaryExpression에서 '+' 연산자 사용 여부 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "LData의 Key는 DB column명을 소문자로 변환하여 저장한다",
          "expectedBehavior": "DB column명을 소문자로 변환하여 저장해야 한다",
          "violationMessage": "LData의 Key는 DB column명을 소문자로 변환하여 저장해야 합니다."
        }
      ]
    },
    {
      "ruleId": "documentation.3_2_1",
      "title": "공통 1) 모든 소스는 Java API Documentation 생성에 부합하도록 주석문을",
      "category": "documentation",
      "checkType": "static_analysis",
      "description": "( 참고 : http://java.sun.com/j2se/javadoc/ ) 2) 여러 줄의 주석문 에는 ‘ /** */ ’ 혹은 ‘ /* */ ’ 을 사용하도록 하며 주석 기호와 내용을 같은 줄에 쓰지 않는다",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "공통",
        "1)",
        "모든",
        "소스는",
        "Java",
        "API",
        "Documentation",
        "생성에",
        "부합하도록",
        "주석문을"
      ],
      "examples": {
        "good": [
          "//#GeneralCodeBlock# 일자정보조회입력 셋팅 //#GeneralCodeBlock# 일자정보조회입력 셋팅 iDtInfoOfr.setString(\"base_dt\", sTxDt);",
          "public class L",
          "private HttpServletRequest r",
          "setString(\"base_dt\", sTxDt)"
        ],
        "bad": []
      },
      "sectionNumber": "3.2.1",
      "businessRules": [],
      "astHints": {
        "nodeTypes": [
          "MethodDeclaration",
          "VariableDeclarator"
        ],
        "checkConditions": [
          "메서드 선언에서 캐스트 연산자 사용 여부"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "documentation.3_2_2",
      "title": "파일 Java 파일 주석문은 생성 정보 등의 파일 전반에 걸친 설명을 포함한다 .",
      "category": "documentation",
      "checkType": "regex_with_validation",
      "description": "Java 파일의 상단 주석문이 생성 정보, 변경 사항 등을 포함해야 하며, Cast Operator 사용 시 커스텀 검증이 필요하다",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "/\\*.*?\\*/",
          "flags": "gs",
          "description": "Java 파일의 주석문 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "파일",
        "Java",
        "주석문은",
        "생성",
        "정보",
        "등의",
        "전반에",
        "걸친",
        "설명을",
        "포함한다"
      ],
      "examples": {
        "good": [
          "/*\n * NAME : TestClass\n * VER : v1.0\n * PROJ : MY Core Banking System\n * Copyright 2012 MY Bank All rights reserved\n */",
          "/*\n * DATE AUTHOR DESCRIPTION\n * ---------- ---------- ------\n * 2012.01.17 홍길동 최초 프로그램 작성\n */"
        ],
        "bad": [
          "// 단일 라인 주석",
          "/*\n * NAME : TestClass\n * VER : v1.0\n */"
        ]
      },
      "sectionNumber": "3.2.2",
      "businessRules": [
        "Java 파일 상단에 파일 전반에 대한 설명을 포함한 주석문이 있어야 한다",
        "주석문은 생성 정보, 변경 사항 등을 포함해야 한다",
        "Cast Operator 사용 시 커스텀 검증 함수가 필요하다"
      ],
      "astHints": {
        "nodeTypes": [
          "BlockComment"
        ],
        "checkConditions": [
          "주석문이 파일 상단에 위치해야 한다"
        ]
      },
      "contextualChecks": [
        {
          "condition": "Cast Operator가 사용된 경우",
          "expectedBehavior": "커스텀 검증 함수가 실행되어야 한다",
          "violationMessage": "Cast Operator 사용 시 커스텀 검증이 필요합니다"
        }
      ]
    },
    {
      "ruleId": "documentation.3_2_3",
      "title": "클래스 1) Class 나 Interface 선언 전에 기술한다 . 2) 설명 주석 형식은",
      "category": "documentation",
      "checkType": "regex_with_validation",
      "description": "클래스나 인터페이스 선언 전에 문서용 주석 /** ... */를 사용하고, 각 라인은 *로 시작하며, <PRE> 태그 안에 기능과 용도를 기술하고, logicalName과 version을 포함해야 한다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "/\\*\\*.*?\\*/",
          "flags": "s",
          "description": "문서용 주석 /** ... */ 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "클래스",
        "1)",
        "Class",
        "Interface",
        "선언",
        "전에",
        "기술한다",
        "2)",
        "설명",
        "주석"
      ],
      "examples": {
        "good": [
          "/**\n * <PRE>\n * 고객의 요청에 의한 해당계좌의 서명계좌여부 , 안전서비스통장여부 , 거래중지좌편입제외여부 , 권유자등을\n * 조회하고 변경 처리한다 .\n * </PRE>\n * @logicalName I 계좌정보등록 Pbc\n * @version 1.0, 2012/01/01\n */\npublic class AccountInfoRegistrationPbc { }",
          "/**\n * <PRE>\n * 사용자 인증 및 권한 검증을 수행한다.\n * </PRE>\n * @logicalName U 사용자인증 Pbc\n * @version 2.0, 2023/05/15\n */\ninterface UserAuthenticationPbc { }"
        ],
        "bad": [
          "public class AccountInfoRegistrationPbc { }",
          "/**\n * 고객의 요청에 의한 해당계좌의 서명계좌여부 , 안전서비스통장여부 , 거래중지좌편입제외여부 , 권유자등을\n * 조회하고 변경 처리한다 .\n * @logicalName I 계좌정보등록 Pbc\n * @version 1.0, 2012/01/01\n */\npublic class AccountInfoRegistrationPbc { }",
          "/**\n * <PRE>\n * 고객의 요청에 의한 해당계좌의 서명계좌여부 , 안전서비스통장여부 , 거래중지좌편입제외여부 , 권유자등을\n * 조회하고 변경 처리한다 .\n * </PRE>\n * @logicalName I 계좌정보등록 Pbc\n */\npublic class AccountInfoRegistrationPbc { }"
        ]
      },
      "sectionNumber": "3.2.3",
      "businessRules": [
        "클래스나 인터페이스 선언 전에 설명 주석을 기술해야 한다.",
        "설명 주석 형식은 문서용 주석 ‘ /** ... */ ’을 사용해야 한다.",
        "설명 주석 안의 각 라인은 ‘ * ’로 시작해야 한다.",
        "클래스에 대한 기능과 용도는 <PRE> 태그 안에 기술해야 한다.",
        "모델의 컴포넌트명을 이용하여 logicalName을 기술해야 한다.",
        "버전명을 기술해야 하며, 날짜 형식은 YYYY/MM/DD로 표기해야 한다."
      ],
      "astHints": {
        "nodeTypes": [
          "ClassDeclaration",
          "InterfaceDeclaration"
        ],
        "checkConditions": [
          "클래스나 인터페이스 선언 전에 주석이 존재하는지 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "클래스나 인터페이스 선언 전에 주석이 존재하지 않거나, 주석 형식이 올바르지 않음",
          "expectedBehavior": "주석이 존재하고, 문서용 주석 형식이 올바르며, <PRE> 태그와 logicalName, version이 포함되어야 함",
          "violationMessage": "클래스나 인터페이스 선언 전에 올바른 문서용 주석이 필요합니다."
        }
      ]
    },
    {
      "ruleId": "documentation.3_2_4",
      "title": "멤버 변수 1) 멤버 변수 상단에 위치한다 . 2) 주석 형식은 문서용 주석",
      "category": "documentation",
      "checkType": "static_analysis",
      "description": "멤버 변수 1) 멤버 변수 상단에 위치한다",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "멤버",
        "변수",
        "1)",
        "상단에",
        "위치한다",
        "2)",
        "주석",
        "형식은",
        "문서용"
      ],
      "examples": {
        "good": [
          "protected Connection c"
        ],
        "bad": []
      },
      "sectionNumber": "3.2.4",
      "businessRules": [],
      "astHints": {
        "nodeTypes": [
          "MethodDeclaration",
          "VariableDeclarator"
        ],
        "checkConditions": [
          "멤버 변수가 클래스 상단에 선언되었는지 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "documentation.3_2_5",
      "title": "멤버 메소드 1) 메소드 상단에 위치한다 . 2) 주석 형식은 문서용 주석",
      "category": "documentation",
      "checkType": "static_analysis",
      "description": "멤버 메소드는 클래스 상단에 위치해야 하며, 문서용 주석 (/** ... */) 형식을 사용해야 한다. 메소드 기능 설명은 간결하게 한두 줄로 기술하고, @serviceID, @logicalName, @param, @return, @exception, @fullPath 태그를 포함해야 한다. LData 타입의 경우 내부 attribute에 대한 타입, key, 설명을 차례로 기술해야 한다. 파라미터와 반환값이 없을 경우 None으로 표기하거나 표기하지 않는다.",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "멤버",
        "메소드",
        "1)",
        "상단에",
        "위치한다",
        "2)",
        "주석",
        "형식은",
        "문서용",
        "Exception"
      ],
      "examples": {
        "good": [
          "public LData t",
          "transferUsbk( LData usbkFtrnInp )",
          "/**\n * 계좌를 등록하기전에 정보를 조회한다.\n * \n * @serviceID 서비스아이디\n * @logicalName 당행이체\n * @param LData usbkFtrnInp 당행이체입력\n * String ebId 전자금융 ID\n * String outamtAcno 출금계좌번호\n * BigDecimal ftrnAmt 거래금액\n * @return LData 당행이체결과\n * String ebId 전자금융 ID\n * String outamtAcno 출금계좌번호\n * @exception LException 에러발생\n * @fullPath 2. 시스템명세모델 ::03. 프로세스컴포넌트 ::IFW01. 선도계좌 :: 이체정보관리 Pbi:: 이체정보관리 Pbi:: 당행이체\n */\npublic LData transferUsbk( LData usbkFtrnInp ) throws LException { }"
        ],
        "bad": [
          "public LData transferUsbk( LData usbkFtrnInp ) throws LException { } // 주석 없음",
          "/**\n * 계좌를 등록하기전에 정보를 조회한다.\n * \n * @serviceID 서비스아이디\n * @logicalName 당행이체\n * @param LData usbkFtrnInp 당행이체입력\n * String ebId 전자금융 ID\n * String outamtAcno 출금계좌번호\n * BigDecimal ftrnAmt 거래금액\n * @return LData 당행이체결과\n * String ebId 전자금융 ID\n * String outamtAcno 출금계좌번호\n * @exception LException 에러발생\n * @fullPath 2. 시스템명세모델 ::03. 프로세스컴포넌트 ::IFW01. 선도계좌 :: 이체정보관리 Pbi:: 이체정보관리 Pbi:: 당행이체\n */\npublic LData transferUsbk( LData usbkFtrnInp ) throws LException { } // 메소드가 클래스 하단에 위치함"
        ]
      },
      "sectionNumber": "3.2.5",
      "businessRules": [
        "멤버 메소드는 클래스 상단에 위치해야 한다.",
        "주석 형식은 문서용 주석 (/** ... */)을 사용해야 한다.",
        "메소드 기능 설명은 한두 줄로 간결하게 기술해야 한다.",
        "serviceID는 PBC 클래스일 경우 기술해야 한다.",
        "logicalName은 모델의 컴포넌트 op 명을 기술해야 한다.",
        "param 태그는 Type, 변수명, 간략한 설명을 포함해야 하며, 한 라인에 하나씩 기술해야 한다.",
        "return value 태그는 Type과 간단한 설명을 포함해야 하며, LData일 경우 내부 attribute에 대한 타입, key, 설명을 차례로 기술해야 한다.",
        "exception 태그는 Exception 명과 발생 상황을 포함해야 하며, 한 라인에 하나씩 기술해야 한다.",
        "fullPath는 논리 모델상의 op에 대한 path를 필요할 경우 함께 표기해야 한다.",
        "LData의 Key는 DB column명을 소문자로 변환하여 저장한다."
      ],
      "astHints": {
        "nodeTypes": [
          "MethodDeclaration",
          "Javadoc"
        ],
        "checkConditions": [
          "MethodDeclaration 노드가 클래스의 상단에 위치하는지 확인",
          "Javadoc 노드가 /** ... */ 형식인지 확인",
          "@serviceID, @logicalName, @param, @return, @exception, @fullPath 태그가 존재하는지 확인",
          "LData 타입의 param과 return에 대해 내부 attribute 정보가 포함되어 있는지 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "LData의 Key가 DB column명을 소문자로 변환하여 저장하는지",
          "expectedBehavior": "LData의 Key는 DB column명을 소문자로 변환하여 저장해야 한다.",
          "violationMessage": "LData의 Key는 DB column명을 소문자로 변환하여 저장해야 합니다."
        }
      ]
    },
    {
      "ruleId": "documentation.3_2_6",
      "title": "SQL 문 1) SQL statement 문 상단에 위치한다 . 2) 주석 형식은 XML",
      "category": "documentation",
      "checkType": "static_analysis",
      "description": "SQL 문은 파일 상단에 위치해야 하며, XML 주석 형식을 사용해야 한다. SQL 문의 개요와 WHERE 절 등에 대한 설명이 필요하며, SELECT, INSERT, DELETE, UPDATE 절 바로 다음에는 작성자명, 소스코드 경로, statement 명이 주석으로 포함되어야 한다.",
      "severity": "HIGH",
      "patterns": [
        {
          "pattern": "${stdd}",
          "flags": "g"
        },
        {
          "pattern": "${endt}",
          "flags": "g"
        },
        {
          "pattern": "${mngr",
          "flags": "g"
        },
        {
          "pattern": "${mngr",
          "flags": "g"
        },
        {
          "pattern": "${mngr",
          "flags": "g"
        }
      ],
      "customValidator": null,
      "keywords": [
        "SQL",
        "1)",
        "statement",
        "상단에",
        "위치한다",
        "2)",
        "주석",
        "형식은",
        "XML",
        "DB"
      ],
      "examples": {
        "good": [
          "DECODE(${mngr_empno}, '', 'Y', B.MNGR_EMPNO)",
          "DECODE(${mngr_empno}, '', 'Y', ${mngr_empno})",
          "<!-- 1) 날자별 List 조회 AND 상각시작일자 BETWEEN ${stdd} AND ${endt} 2) 관리자직원별 List 조회 AND DECODE(${mngr_empno}, '', 'Y', B.MNGR_EMPNO) = DECODE(${mngr_empno}, '', 'Y', ${mngr_empno}) -->\n<!-- 대손상각계좌목록조회 -->\n<statement name=\"retrieveListChofAcco\">\n<![CDATA[\nSELECT /* 이용규 /pln/fumn/spbn/chofBsicEBi/ChofAccoBsic.xml - retrieveListChofAcco */\nA.SPPC_LEDGR_NO ,\nA.LNBZ_ACNO ,\nA.GDS_CD ,'N/A' AS GDS_NM ,\nA.CPT_PPCD ,\nA.LOAN_DT ,\nA.EXPR_DT ,\nA.LOAN_RT ,\nA.LNAM ,\nA.LOAN_BAL ,\nA.PCOV_AMT ,\nA.INOV_AMT ,\nA.OVRD_INT ,\nA.SPPAM ,\nA.OVRD_DT ,\nA.SDNS_CLSS_DT ,\nA.ASQL_CLCD ,\nA.SPBN_ENRL_DVCD ,\nA.SPBN_ENRL_DT ,\nB.PRGS_STCD \nFROM CLPCCHOFFD A ,CLPCCHOFFM B\nWHERE A.SPPC_LEDGR_NO = B.SPPC_LEDGR_NO\nAND B.DPRC_STDD BETWEEN ${stdd} AND ${endt}\nAND DECODE(${mngr_empno}, '', 'Y', B.MNGR_EMPNO) = DECODE(${mngr_empno}, '', 'Y', ${mngr_empno})\n]]>\n</statement>"
        ],
        "bad": [
          "<statement name=\"retrieveListChofAcco\">\n<![CDATA[\nSELECT /* 이용규 /pln/fumn/spbn/chofBsicEBi/ChofAccoBsic.xml - retrieveListChofAcco */\nA.SPPC_LEDGR_NO ,\nA.LNBZ_ACNO ,\nA.GDS_CD ,'N/A' AS GDS_NM ,\nA.CPT_PPCD ,\nA.LOAN_DT ,\nA.EXPR_DT ,\nA.LOAN_RT ,\nA.LNAM ,\nA.LOAN_BAL ,\nA.PCOV_AMT ,\nA.INOV_AMT ,\nA.OVRD_INT ,\nA.SPPAM ,\nA.OVRD_DT ,\nA.SDNS_CLSS_DT ,\nA.ASQL_CLCD ,\nA.SPBN_ENRL_DVCD ,\nA.SPBN_ENRL_DT ,\nB.PRGS_STCD \nFROM CLPCCHOFFD A ,CLPCCHOFFM B\nWHERE A.SPPC_LEDGR_NO = B.SPPC_LEDGR_NO\nAND B.DPRC_STDD BETWEEN ${stdd} AND ${endt}\nAND DECODE(${mngr_empno}, '', 'Y', B.MNGR_EMPNO) = DECODE(${mngr_empno}, '', 'Y', ${mngr_empno})\n]]>\n</statement>"
        ]
      },
      "sectionNumber": "3.2.6",
      "businessRules": [
        "SQL 문은 파일 상단에 위치해야 한다.",
        "주석 형식은 XML 주석 (<! -- ... -- >) 을 사용해야 한다.",
        "SQL statement 개요를 기술해야 한다.",
        "WHERE 절 등에 추가적인 설명이 필요한 조건에 대해서는 추가적인 설명을 기술해야 한다.",
        "SELECT, INSERT, DELETE, UPDATE 절 바로 다음에는 작성자명, 소스코드 경로, statement 명을 주석으로 입력해야 한다."
      ],
      "astHints": {
        "nodeTypes": [
          "Statement",
          "Comment"
        ],
        "checkConditions": [
          "SQL 문이 파일 상단에 위치하는지 확인",
          "XML 주석 형식을 사용하는지 확인",
          "SQL 개요 및 조건 설명이 포함되어 있는지 확인",
          "SELECT, INSERT, DELETE, UPDATE 절 바로 다음에 작성자명, 소스코드 경로, statement 명이 주석으로 포함되어 있는지 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "SQL 문이 파일 상단에 위치하지 않음",
          "expectedBehavior": "SQL 문은 파일 상단에 위치해야 함",
          "violationMessage": "SQL 문은 파일 상단에 위치해야 합니다."
        },
        {
          "condition": "XML 주석 형식을 사용하지 않음",
          "expectedBehavior": "XML 주석 형식을 사용해야 함",
          "violationMessage": "주석 형식은 XML 주석 (<! -- ... -- >) 을 사용해야 합니다."
        },
        {
          "condition": "SQL 개요 및 조건 설명이 누락됨",
          "expectedBehavior": "SQL statement 개요와 WHERE 절 등에 대한 설명이 필요함",
          "violationMessage": "SQL statement 개요를 기술해야 하며, WHERE 절 등에 추가적인 설명이 필요한 조건에 대해서는 추가적인 설명을 기술해야 합니다."
        },
        {
          "condition": "SELECT, INSERT, DELETE, UPDATE 절 바로 다음에 작성자명, 소스코드 경로, statement 명이 주석으로 포함되지 않음",
          "expectedBehavior": "SELECT, INSERT, DELETE, UPDATE 절 바로 다음에는 작성자명, 소스코드 경로, statement 명을 주석으로 입력해야 함",
          "violationMessage": "SELECT, INSERT, DELETE, UPDATE 절 바로 다음에는 작성자명, 소스코드 경로, statement 명을 주석으로 입력해야 합니다."
        }
      ]
    },
    {
      "ruleId": "documentation.3_2_7",
      "title": "기타 1) 코드 내부에 특별한 사항을 기술 할 경우 행 단위 주석 (//) 을 사용하지만",
      "category": "documentation",
      "checkType": "regex_with_validation",
      "description": "코드 내부에 특별한 사항을 기술할 때 행 단위 주석(//)을 사용하지만, 가급적 사용을 줄인다. 특히 멤버 변수 정의 시 인자들이 많을 경우 각 인자를 한 행에 하나씩 기술하고, 같은 행에 짧은 주석을 기재할 수 있다. 이 경우 주석문은 코드와 많은 간격을 두어 코드가 산만해지지 않도록 한다. 또한, 주석의 시작은 항상 라인의 처음에서 시작해야 하며, 코드 블록 내에서 주석의 사용을 자제해야 한다.",
      "severity": "MEDIUM",
      "patterns": [
        {
          "pattern": "^\\s*//.*$",
          "flags": "gm",
          "description": "행 단위 주석이 라인의 처음에서 시작하는지 확인"
        }
      ],
      "customValidator": null,
      "keywords": [
        "기타",
        "1)",
        "코드",
        "내부에",
        "특별한",
        "사항을",
        "기술",
        "경우",
        "단위",
        "주석"
      ],
      "examples": {
        "good": [
          "taWagImpRt = gdPriImpRt.multiply( tMul );",
          "multiply( tMul )",
          "int value = (int) obj; // 캐스트 연산자 사용",
          "int value = (int) obj; // 캐스트 연산자 사용\nint value2 = (int) obj2; // 캐스트 연산자 사용"
        ],
        "bad": [
          "int value = (int) obj; // 캐스트 연산자 사용\nint value2 = (int) obj2; // 캐스트 연산자 사용"
        ]
      },
      "sectionNumber": "3.2.7",
      "businessRules": [
        "코드 내부에 특별한 사항을 기술할 때 행 단위 주석(//)을 사용하지만, 가급적 사용을 줄인다.",
        "멤버 변수를 정의할 경우 인자들이 많을 경우 각 인자를 한 행에 하나씩 기술하고, 같은 행에 짧은 주석을 기재할 수 있다.",
        "주석문은 코드와 많은 간격을 두어 코드가 산만해지지 않도록 한다.",
        "주석의 시작은 항상 라인의 처음에서 시작한다.",
        "코드 블록 내에서 주석의 사용을 자제한다.",
        "Big Decimal 연산 로직이 있을 경우, 로직 바로 위에 연산식에 대한 수식을 주석으로 표기한다."
      ],
      "astHints": {
        "nodeTypes": [
          "VariableDeclarator",
          "MethodDeclaration"
        ],
        "checkConditions": [
          "멤버 변수 정의 시 인자들이 많을 경우 각 인자를 한 행에 하나씩 기술하고, 같은 행에 짧은 주석을 기재할 수 있는지 확인",
          "주석의 시작이 라인의 처음에서 시작하는지 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "LData의 Key는 DB column명을 소문자로 변환하여 저장한다",
          "expectedBehavior": "DB column명을 소문자로 변환하여 저장",
          "violationMessage": "LData의 Key는 DB column명을 소문자로 변환하여 저장해야 합니다."
        }
      ]
    },
    {
      "ruleId": "code_style.3_1_3",
      "title": "빈 줄 삽입 다음과 같은 경우에 하나의 빈 줄을 삽입한다 . 1) 주석과 Package 명",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "Java 소스 코드에서 빈 줄 삽입 규칙을 검사합니다. 주석과 패키지 선언 사이, import 문 사이, 메서드 내 로컬 변수와 첫 번째 구문 사이, 그리고 구문들 사이에 적절한 빈 줄을 삽입해야 합니다.",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "삽입",
        "다음과",
        "같은",
        "경우에",
        "하나의",
        "줄을",
        "삽입한다",
        "1)",
        "주석과",
        "Package"
      ],
      "examples": {
        "good": [
          "package com.example;\n\nimport java.util.*;\n\npublic class Example {\n    public void method() {\n        int a = 1;\n\n        if (a > 0) {\n            System.out.println(\"positive\");\n        }\n    }\n}",
          "public class Example1 {\n    // First class\n}\n\n\npublic class Example2 {\n    // Second class\n}\n"
        ],
        "bad": [
          "package com.example;\nimport java.util.*;\n\npublic class Example {\n    public void method() {\n        int a = 1;\n        if (a > 0) {\n            System.out.println(\"positive\");\n        }\n    }\n}",
          "public class Example1 {\n    // First class\n}\npublic class Example2 {\n    // Second class\n}\n"
        ]
      },
      "sectionNumber": "3.1.3",
      "businessRules": [
        "주석과 패키지 선언 사이에 하나의 빈 줄을 삽입해야 한다",
        "패키지 선언문과 첫 번째 import 문 사이에 하나의 빈 줄을 삽입해야 한다",
        "서로 다른 성격의 import 문 사이에 하나의 빈 줄을 삽입해야 한다",
        "Method 속의 로컬 변수들과 첫 번째 구문 사이에 하나의 빈 줄을 삽입해야 한다",
        "주석의 앞에 하나의 빈 줄을 삽입해야 한다",
        "if-else, loop, switch, try-catch-finally 문 앞뒤에 하나의 빈 줄을 삽입해야 한다",
        "소스 코드를 의미상 섹션으로 구분할 때 두 개의 빈 줄을 삽입해야 한다",
        "하나의 파일에 하나 이상의 클래스 혹은 인터페이스가 정의되어 있을 때 각 클래스나 인터페이스를 구분할 때 두 개의 빈 줄을 삽입해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "PackageDeclaration",
          "ImportDeclaration",
          "MethodDeclaration",
          "VariableDeclaration",
          "BlockStatement"
        ],
        "checkConditions": [
          "파일 상단의 주석과 패키지 선언 사이에 빈 줄이 있는지 확인",
          "import 문 사이에 빈 줄이 있는지 확인",
          "메서드 내 로컬 변수와 첫 번째 구문 사이에 빈 줄이 있는지 확인",
          "구문들 사이에 적절한 빈 줄이 있는지 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_3_3",
      "title": "클래스 1) 클래스의 선언은 첫 번째 column 에서 시작한다 . 2) 선언이 여러 li",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "클래스 선언은 첫 번째 column에서 시작해야 하며, 여러 줄로 구성될 경우 적절한 들여쓰기를 사용해야 한다. 클래스 내부 선언 순서는 상수 변수 → 클래스 변수 → 인스턴스 변수 → 멤버 메소드 순서로 구성되어야 하며, 클래스 변수는 모든 인스턴스에서 공유되어야 하는 경우에만 사용해야 한다. 또한 패키지 구조 변경 시 패키지명을 포함한 클래스명 사용은 피해야 한다.",
      "severity": "HIGH",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "클래스",
        "1)",
        "클래스의",
        "선언은",
        "번째",
        "column",
        "에서",
        "시작한다",
        "2)",
        "선언이"
      ],
      "examples": {
        "good": [
          "cif = null ... ( X ) import sf.work010.entity.Tbcif10Entity;",
          "cif = serarchCustomer(custNo);",
          "public class L",
          "private Label l",
          "serarchCustomer(custNo)"
        ],
        "bad": [
          "    public class LoginView extends Frame implements ActionListener, TextListener {\n        // 클래스 선언이 첫 번째 column이 아님\n    }",
          "import sf.work010.entity.Tbcif10Entity;\nTbcif10Entity cif = searchCustomer(custNo);\n// 패키지명을 포함한 클래스명 사용"
        ]
      },
      "sectionNumber": "3.3.3",
      "businessRules": [
        "클래스 선언은 첫 번째 column에서 시작해야 한다.",
        "클래스 선언이 여러 줄로 구성될 경우 적절한 들여쓰기를 사용해야 한다.",
        "클래스 내부 선언 순서는 상수 변수 → 클래스 변수 → 인스턴스 변수 → 멤버 메소드 순서로 구성되어야 한다.",
        "클래스 변수는 모든 인스턴스에서 공유되어야 하는 경우에만 사용해야 한다.",
        "패키지 구조 변경 시 패키지명을 포함한 클래스명 사용은 피해야 한다."
      ],
      "astHints": {
        "nodeTypes": [
          "ClassDeclaration",
          "VariableDeclaration",
          "MethodDeclaration"
        ],
        "checkConditions": [
          "ClassDeclaration의 위치가 첫 번째 column인지 확인",
          "VariableDeclaration의 선언 순서가 상수 → 클래스 → 인스턴스 변수 순서인지 확인",
          "MethodDeclaration의 선언 순서가 클래스 선언 메소드 → 인스턴스 메소드 → 생성자 → main 메소드 순서인지 확인"
        ]
      },
      "contextualChecks": [
        {
          "condition": "클래스 선언이 첫 번째 column에서 시작하지 않음",
          "expectedBehavior": "클래스 선언은 첫 번째 column에서 시작해야 함",
          "violationMessage": "클래스 선언은 첫 번째 column에서 시작해야 합니다."
        },
        {
          "condition": "패키지명을 포함한 클래스명 사용",
          "expectedBehavior": "패키지명을 포함한 클래스명 사용은 피해야 함",
          "violationMessage": "패키지 구조 변경 시 패키지명을 포함한 클래스명 사용은 피해야 합니다."
        }
      ]
    },
    {
      "ruleId": "code_style.3_3_4",
      "title": "클래스 메소드 1) 메소드 선언은 클래스가 선언된 컬럼에서 4 컬럼을 들여서 시작한다 .",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "클래스 메소드 선언에 대한 들여쓰기, 인자 형식, 반환 타입 명확성 규칙을 검사합니다.",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "클래스",
        "메소드",
        "1)",
        "선언은",
        "클래스가",
        "선언된",
        "컬럼에서",
        "컬럼을",
        "들여서",
        "시작한다"
      ],
      "examples": {
        "good": [
          "open 한 파일의 close open 한 cursor 의 close open 한 데이터베이스 session 의 close open 한 소켓의 close 8) 더 이상 사용되지 않을 객체 인스턴스는 변수에 null 을 대입하여 제거한다 . 9) 각 메소드의 return",
          "showMsgbox()",
          "class MyClass {\n    public void myMethod() {\n        // code\n    }\n}",
          "class MyClass {\n    public void myMethod(int param1, String param2) {\n        // code\n    }\n}"
        ],
        "bad": [
          "class MyClass {\n        public void myMethod() {\n            // code\n        }\n    }",
          "class MyClass {\n    public void myMethod( int param1, String param2 ) {\n        // code\n    }\n}"
        ]
      },
      "sectionNumber": "3.3.4",
      "businessRules": [
        "메소드 선언은 클래스가 선언된 컬럼에서 4 컬럼을 들여서 시작해야 한다",
        "메소드 이름과 여는 괄호 사이에는 공백을 두지 않는다",
        "여는 괄호 뒤와 닫는 괄호 앞에는 적어도 하나 이상의 공백을 둔다",
        "메소드에 인자가 없을 때에는 아무것도 쓰지 않는다",
        "한 줄에 여러 개의 parameter 를 기술할 수 있고, 이러한 경우에는 각각의 인자를 comma 로 분리한다",
        "comma 앞에는 공백을 두지 말고, 뒤에는 적어도 하나 이상의 공백을 둔다",
        "선언이 여러 line 에 걸쳐질 경우, 각 line 의 첫번째 parameter 를 정렬하고, 여는 괄호와 닫는 괄호를 정렬시킨다",
        "필요한 경우 finally 에서 cleanup operation 을 수행하도록 한다",
        "더 이상 사용되지 않을 객체 인스턴스는 변수에 null 을 대입하여 제거한다",
        "각 메소드의 return type 을 명료하게 선언한다"
      ],
      "astHints": {
        "nodeTypes": [
          "MethodDeclaration",
          "VariableDeclarator"
        ],
        "checkConditions": [
          "MethodDeclaration의 들여쓰기 여부 확인",
          "MethodDeclaration의 파라미터 형식 확인",
          "MethodDeclaration의 반환 타입 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_3_5",
      "title": "변수 1) 멤버 변수 기술 순서는 constant - > static - > primiti",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "멤버 변수 선언 순서는 constant -> static -> primitive -> reference 변수 순서로 정렬되어야 하며, 변수 선언 시 들여쓰기, 한 줄에 하나의 변수 선언, 타입 그룹 선언, Loop 변수 선언 위치, 사용되지 않는 변수 선언 금지, 초기화 규칙 등이 적용되어야 한다.",
      "severity": "HIGH",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "변수",
        "1)",
        "멤버",
        "기술",
        "순서는",
        "constant",
        "static",
        "primiti",
        "class",
        "메소드"
      ],
      "examples": {
        "good": [
          "memberNameStr = null;",
          "rentalItemStr = null;",
          "public class L",
          "private Label l",
          "confirmRentalInfo()"
        ],
        "bad": [
          "private int count;\nprivate static int MAX = 10;\nprivate String name;",
          "int i = 0, j = 1;"
        ]
      },
      "sectionNumber": "3.3.5",
      "businessRules": [
        "멤버 변수는 constant -> static -> primitive -> reference 변수 순서로 선언해야 한다.",
        "멤버 변수 선언은 클래스 첫 컬럼으로부터 4칸 들여쓰기를 해야 한다.",
        "한 줄에 하나의 변수만 선언해야 하며, 마지막 semicolon 앞에는 공백을 두지 않는다.",
        "같은 타입의 변수는 그룹으로 선언해야 한다.",
        "Loop 변수는 Loop 내에서 선언하여 사용해야 하며, inx, jnx, knx 형식을 사용해야 한다.",
        "쓰이지 않는 멤버 변수 또는 로컬 변수는 선언하지 않아야 한다.",
        "멤버 변수는 필요 시 생성자나 메소드 내에서 초기화해야 한다.",
        "자동(로컬) 변수는 선언 시 반드시 초기화해야 한다.",
        "flag 변수, 누적 counter, return code를 저장하는 변수는 반드시 초기화해야 한다.",
        "Array 선언은 type[] arrayname 형식으로 선언해야 한다."
      ],
      "astHints": {
        "nodeTypes": [
          "FieldDeclaration",
          "VariableDeclarator",
          "ForStatement",
          "MethodDeclaration"
        ],
        "checkConditions": [
          "멤버 변수 선언 순서 확인",
          "변수 선언 위치 및 들여쓰기 확인",
          "한 줄에 하나의 변수 선언 확인",
          "타입 그룹 선언 확인",
          "Loop 변수 선언 위치 확인",
          "사용되지 않는 변수 선언 여부 확인",
          "멤버 변수 초기화 확인",
          "로컬 변수 초기화 확인",
          "Array 선언 형식 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_6_1",
      "title": "공통 1) 두 문장을 한 줄에 코딩하지 않는다 . 2) 중첩된 문장에서는 상위문장의 시작에",
      "category": "code_style",
      "checkType": "regex_with_validation",
      "description": "Cast Operator는 반드시 올바른 형식으로 사용되어야 하며, 타입 캐스팅이 필요한 경우에만 사용되어야 한다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "\\(\\s*\\w+\\s*\\)\\s*\\w+",
          "flags": "g",
          "description": "Cast Operator 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "공통",
        "1)",
        "문장을",
        "줄에",
        "코딩하지",
        "않는다",
        "2)",
        "중첩된",
        "문장에서는",
        "상위문장의"
      ],
      "examples": {
        "good": [
          "getDatafile( \"input.dat\" )",
          "getDatafile( \"output.dat\" )",
          "int x = (int) obj;",
          "String s = (String) obj;"
        ],
        "bad": [
          "int x = (int) obj",
          "int x = (int) obj; int y = (int) obj;"
        ]
      },
      "sectionNumber": "3.6.1",
      "businessRules": [
        "Cast Operator는 타입 캐스팅이 필요한 경우에만 사용되어야 한다",
        "Cast Operator는 반드시 올바른 형식으로 사용되어야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "CastExpression"
        ],
        "checkConditions": [
          "AST 노드가 CastExpression인지 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_6_2",
      "title": "Compound statement 1) 메소드 body 내에서의 모든 선언문이나 문장은 들",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "메소드 body 내에서의 모든 선언문이나 문장은 들여쓰기를 해야 하며, 여는 brace는 사용하고자 하는 곳의 제일 끝에 위치하고, 닫는 brace는 여는 brace를 시작하는 문장에 들여쓰기 위치에 맞춘다.",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "Compound",
        "statement",
        "1)",
        "메소드",
        "body",
        "내에서의",
        "모든",
        "선언문이나",
        "문장은"
      ],
      "examples": {
        "good": [
          "Count = 0;",
          "i = 0 ;",
          "private void s",
          "showSerial()",
          "getSerialNo()"
        ],
        "bad": [
          "private void showSerial() {\nint Count = 0;\n    if ( stTape.getSerialNo() == null ) {\nparentFrame.showWarningDialog( \" 시리얼 번호 검색오류 \" );\n        tfSerialNo.selectAll();\n    } else {\ntfDailyPrice.setText( stCtlgItem.getRentPrice() );\n        tfRentalTerm.setText( \"2\" );\n    }\n}"
        ]
      },
      "sectionNumber": "3.6.2",
      "businessRules": [
        "메소드 body 내에서의 모든 선언문이나 문장은 들여쓰기를 해야 한다",
        "여는 brace는 사용하고자 하는 곳의 제일 끝에 위치해야 한다",
        "닫는 brace는 여는 brace를 시작하는 문장에 들여쓰기 위치에 맞춘다"
      ],
      "astHints": {
        "nodeTypes": [
          "MethodDeclaration",
          "BlockStatement"
        ],
        "checkConditions": [
          "MethodDeclaration 내의 BlockStatement의 들여쓰기 여부 확인",
          "BlockStatement 내의 모든 문장들이 동일한 들여쓰기 수준을 가지는지 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_6_3",
      "title": "The for statement 1) for 다음 공백 , 괄호 열고 공백 , 내용 쓰고",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "for문 구조를 찾는 정규식",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "The",
        "for",
        "statement",
        "1)",
        "다음",
        "공백",
        "괄호",
        "열고",
        "내용",
        "쓰고"
      ],
      "examples": {
        "good": [
          "inx = 0 ;",
          "getItemCount()",
          "RentalItemEntity()"
        ],
        "bad": []
      },
      "sectionNumber": "3.6.3",
      "businessRules": [],
      "astHints": {},
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_6_4",
      "title": "The while Statement 1) while 다음에 공백을 넣고 , 괄호 열고 공백",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "while 키워드 뒤에 공백이 있고, 괄호가 올바르게 열리고 닫히는 패턴",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "The",
        "while",
        "Statement",
        "1)",
        "다음에",
        "공백을",
        "넣고",
        "괄호",
        "열고",
        "공백"
      ],
      "examples": {
        "good": [
          "next()",
          "ClubMemberShipEntity( result.getString(1)"
        ],
        "bad": []
      },
      "sectionNumber": "3.6.4",
      "businessRules": [],
      "astHints": {},
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_6_5",
      "title": "The do statement 1) do keyword 를 한 line 자체에 둔다 . 2",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "do-while 문은 do 키워드가 한 줄에 위치하고, do 문장은 다음 줄에 들여쓰기를 하며, while 조건은 괄호 내부에 공백을 포함하여 작성되어야 하며, while 문장 끝에는 세미콜론이 있어야 합니다.",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "The",
        "do",
        "statement",
        "1)",
        "keyword",
        "line",
        "자체에",
        "둔다"
      ],
      "examples": {
        "good": [
          "semicolon(;)",
          "do {\n    System.out.println(\"Hello\");\n} while (isOk);",
          "do {\n    int x = 10;\n} while (x > 0);"
        ],
        "bad": [
          "do { System.out.println(\"Hello\"); } while (isOk);",
          "do\n{\n    System.out.println(\"Hello\");\n} while(isOk);",
          "do {\n    System.out.println(\"Hello\");\n} while ( isOk );"
        ]
      },
      "sectionNumber": "3.6.5",
      "businessRules": [
        "do 키워드는 한 줄에 위치해야 한다.",
        "do 문장은 다음 줄에 들여쓰기를 해야 한다.",
        "while 다음에는 공백이 있어야 하며, 괄호 열기 전과 닫기 전에도 공백이 있어야 한다.",
        "while 문장이 끝나면 닫는 괄호 뒤에 세미콜론이 있어야 한다."
      ],
      "astHints": {
        "nodeTypes": [
          "DoWhileStatement"
        ],
        "checkConditions": [
          "do 키워드가 한 줄에 위치하는지 확인",
          "do 문장이 다음 줄에 들여쓰기 되었는지 확인",
          "while 조건이 괄호 내부에 공백을 포함하여 작성되었는지 확인",
          "while 문장 끝에 세미콜론이 있는지 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_6_6",
      "title": "The if and if - else Statement 1) if 다음에 공백을 넣고 ,",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "if 키워드 뒤에 공백이 있는지 확인하는 패턴",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "The",
        "if",
        "and",
        "else",
        "Statement",
        "1)",
        "다음에",
        "공백을",
        "넣고"
      ],
      "examples": {
        "good": [
          "getSerialNo()",
          "showWarningDialog( \" 시리얼 번호 검색오류 \" )"
        ],
        "bad": []
      },
      "sectionNumber": "3.6.6",
      "businessRules": [],
      "astHints": {},
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_6_7",
      "title": "The switch Statement 1) switch keyword 와 Test Expr",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "switch 문의 구조와 들여쓰기 규칙을 검사합니다. switch 키워드와 테스트 표현식은 같은 줄에 위치해야 하며, 중괄호는 다음 줄에 시작됩니다. case 및 default 라벨은 switch 문 내에서 일정한 들여쓰기를 따라야 하며, 한 줄에 여러 case 또는 default 라벨을 허용하지 않습니다.",
      "severity": "MEDIUM",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "The",
        "switch",
        "Statement",
        "1)",
        "keyword",
        "Test",
        "Expr"
      ],
      "examples": {
        "good": [
          "delete()",
          "switch (respCode) {\n    case 1:\n        add();\n        break;\n    case 2:\n        delete();\n        break;\n    default:\n        System.out.println(err_msg);\n        break;\n}",
          "switch (x) {\n    case 0:\n        System.out.println(\"zero\");\n        break;\n    case 1:\n        System.out.println(\"one\");\n        break;\n    default:\n        System.out.println(\"other\");\n        break;\n}"
        ],
        "bad": [
          "switch(respCode) {\n    case 1:\n        add();\n        break;\n    case 2:\n        delete();\n        break;\n    default:\n        System.out.println(err_msg);\n        break;\n}",
          "switch (respCode)\n{\n    case 1:\n        add();\n        break;\n    case 2:\n        delete();\n        break;\n    default:\n        System.out.println(err_msg);\n        break;\n}"
        ]
      },
      "sectionNumber": "3.6.7",
      "businessRules": [
        "switch 키워드와 테스트 표현식은 같은 줄에 위치해야 한다",
        "switch 문의 중괄호는 다음 줄에 시작되어야 한다",
        "case 및 default 라벨은 switch 문 내에서 일정한 들여쓰기를 따라야 한다",
        "한 줄에 하나 이상의 case 또는 default 라벨을 허용하지 않는다",
        "default 레이블은 프로그램의 판독성을 높이기 위해 사용을 권장한다",
        "default case에도 break 문을 달아주는 것이 좋다"
      ],
      "astHints": {
        "nodeTypes": [
          "SwitchStatement"
        ],
        "checkConditions": [
          "SwitchStatement의 테스트 표현식이 switch 키워드와 같은 줄에 위치하는지 확인",
          "SwitchStatement의 중괄호가 다음 줄에 시작되는지 확인",
          "case 및 default 라벨의 들여쓰기 규칙을 확인",
          "한 줄에 여러 case 또는 default 라벨이 존재하지 않는지 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_6_8",
      "title": "try - catch statement 1) try keyword 를 한 line 자체에",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "try-catch 문의 구조와 들여쓰기 규칙을 검사합니다. try 키워드는 한 줄에 위치하고, try 블록 내용은 다음 줄에 들여쓰기하며, catch 키워드는 try 키워드와 같은 컬럼에 정렬되어야 합니다.",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "try",
        "catch",
        "statement",
        "1)",
        "keyword",
        "line",
        "자체에",
        "Exception",
        "column",
        "변수"
      ],
      "examples": {
        "good": [
          "dailyPrice = Integer.parseInt( tfDailyPrice.getText() );",
          "parseInt( tfDailyPrice.getText()",
          "println( \"NumberFormat Exception\" )",
          "try {\n    dailyPrice = Integer.parseInt( tfDailyPrice.getText() );\n} catch ( NumberFormatException e ) {\n    System.out.println( \"NumberFormat Exception\" );\n    parentFrame.showWarningDialog( \" 일일 대여료 입력오류 \" );\n    tfDailyPrice.selectAll();\n    return;\n} finally {\n    // finally 내용\n}",
          "try {\n    // some code\n} catch ( Exception e ) {\n    // exception handling\n} finally {\n    // finally content\n}"
        ],
        "bad": [
          "try {\n    dailyPrice = Integer.parseInt( tfDailyPrice.getText() );\n} catch ( NumberFormatException e ) {\n    System.out.println( \"NumberFormat Exception\" );\n    parentFrame.showWarningDialog( \" 일일 대여료 입력오류 \" );\n    tfDailyPrice.selectAll();\n    return;\n} finally {\n    // finally 내용\n}"
        ]
      },
      "sectionNumber": "3.6.8",
      "businessRules": [
        "try 키워드는 한 줄에 위치해야 한다",
        "try 문장을 구성하는 문장은 다음 줄에 들여쓰기를 해야 한다",
        "catch 키워드는 try 키워드와 같은 column에 정렬되어야 한다",
        "catch 문장은 괄호 열고 공백, Exception 명과 변수 명을 쓰고, 괄호 닫기 전에 공백을 넣어야 한다",
        "catch 문장이 끝나면 괄호를 열어 Exception 에 대한 문장들을 다음 줄에 4 칸 이상 띄워서 위치시켜야 한다",
        "finally 키워드는 catch 문장을 구성하는 내용이 끝나는 그 다음 line에 써야 하며, try keyword 와 같은 column에 정렬시켜야 한다",
        "finally 다음에 괄호를 열어 필요한 문장들을 다음 줄에 들여쓰기해야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "TryStatement",
          "CatchClause",
          "FinallyClause"
        ],
        "checkConditions": [
          "TryStatement의 try 키워드가 한 줄에 위치하는지 확인",
          "TryStatement의 try 블록 내용이 다음 줄에 들여쓰기 되었는지 확인",
          "CatchClause의 catch 키워드가 try 키워드와 같은 컬럼에 정렬되어 있는지 확인",
          "CatchClause의 예외 처리 문장이 4칸 이상 들여쓰기 되었는지 확인",
          "FinallyClause가 catch 문장 끝난 후에 위치하고, try 키워드와 같은 컬럼에 정렬되어 있는지 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_7_1",
      "title": "Binary or Ternary Arithmetic or Logical Operators",
      "category": "code_style",
      "checkType": "regex_with_validation",
      "description": "C++의 Cast Operator (예: static_cast<int>(x))에서 괄호 내부에 공백이 없을 경우 위반됩니다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "static_cast<[^>]+>\\([^)]*\\)",
          "flags": "g",
          "description": "C++의 Cast Operator 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "Binary",
        "or",
        "Ternary",
        "Arithmetic",
        "Logical",
        "Operators"
      ],
      "examples": {
        "good": [
          "fahren = celsius * 1.8 + 32 ;",
          "xPix = xCoo * xCcale + xAxisPix ;",
          "int x = static_cast<int>( x );",
          "int y = dynamic_cast<int>( y );"
        ],
        "bad": [
          "int x = static_cast<int>(x);",
          "int y = dynamic_cast<int>(y);"
        ]
      },
      "sectionNumber": "3.7.1",
      "businessRules": [
        "Cast Operator 내부 괄호에 공백이 없으면 위반됩니다.",
        "C++의 Cast Operator는 괄호 내부에 공백을 포함해야 합니다."
      ],
      "astHints": {
        "nodeTypes": [
          "CallExpression"
        ],
        "checkConditions": [
          "CallExpression의 arguments에 공백이 없는 경우 위반"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_7_2",
      "title": "Unary Arithmetic or Logical Operator 단항 연산자나 논리 연산",
      "category": "code_style",
      "checkType": "regex",
      "description": "단항 산술 연산자(-)나 논리 연산자(!) 사용 시, 연산자와 피연산자 사이에는 공백을 사용하지 않는다. 예를 들어 '-jnx'와 '!oldStatus'는 올바른 형식이며, '- jnx'나 '! oldStatus'는 허용되지 않는다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "\\s*[!\\-]\\s+\\w",
          "flags": "g",
          "description": "단항 연산자 또는 논리 연산자 뒤에 공백이 있는 경우를 검출"
        },
        {
          "pattern": "\\s*[!\\-]\\s*\\w",
          "flags": "g",
          "description": "단항/논리 연산자와 피연산자 사이에 공백이 있는 경우를 검출"
        }
      ],
      "customValidator": null,
      "keywords": [
        "Unary",
        "Arithmetic",
        "or",
        "Logical",
        "Operator",
        "단항",
        "연산자나",
        "논리",
        "연산"
      ],
      "examples": {
        "good": [
          "inx = - jnx;",
          "newStatus = ! oldStatus;",
          "inx = -jnx;",
          "newStatus = !oldStatus;"
        ],
        "bad": [
          "inx = - jnx;",
          "newStatus = ! oldStatus;"
        ]
      },
      "sectionNumber": "3.7.2",
      "businessRules": [
        "단항 연산자와 피연산자 사이에는 공백을 사용하지 않는다.",
        "논리 연산자와 피연산자 사이에는 공백을 사용하지 않는다."
      ],
      "astHints": {
        "nodeTypes": [
          "UnaryExpression"
        ],
        "checkConditions": [
          "UnaryExpression 노드의 operator가 '-' 또는 '!'인 경우, operand와 operator 사이에 공백이 없어야 한다."
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_7_3",
      "title": "Cast Operator Cast 연산자를 사용할 때에는 공백의 사용을 최소화 해야 한다",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "Cast Operator 패턴: (Type) variable 형태",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "\\(\\s*[A-Z][a-zA-Z0-9<>]*\\s*\\)\\s{2,}[a-zA-Z_]",
          "flags": "g",
          "description": "Cast 연산자 뒤 2칸 이상 공백"
        },
        {
          "pattern": "\\(\\s+[A-Z][a-zA-Z0-9<>]*\\s+\\)\\s*[a-zA-Z_]",
          "flags": "g",
          "description": "Cast 연산자 괄호 내부 공백"
        }
      ],
      "customValidator": null,
      "keywords": [
        "Cast",
        "Operator",
        "연산자를",
        "사용할",
        "때에는",
        "공백의",
        "사용을",
        "최소화",
        "해야",
        "한다"
      ],
      "examples": {
        "good": [
          "xScale = (float)xCooEnd / xAxisLin ;"
        ],
        "bad": []
      },
      "sectionNumber": "3.7.3",
      "businessRules": [],
      "astHints": {},
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_7_4",
      "title": "Comma Operator Comma 연산자 사용 시 , 그 앞에는 공백을 두지 말고 오른",
      "category": "code_style",
      "checkType": "regex_with_validation",
      "description": "Comma Operator 사용 시, 왼쪽에는 공백을 두지 않고 오른쪽에는 한 칸의 공백을 두어야 한다. 이는 영문법과 일치하며 가독성을 높인다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "\\s*,\\s*",
          "flags": "g",
          "description": "콤마 연산자 앞뒤 공백 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "Comma",
        "Operator",
        "연산자",
        "사용",
        "앞에는",
        "공백을",
        "두지",
        "말고",
        "오른"
      ],
      "examples": {
        "good": [
          "inx = 3, jnx = 17 ;",
          "mapPoint( inx , jnx )",
          "for (inx = 3, jnx = 17; inx < X_END; inx++, jnx++) { mapPoint(inx, jnx); }",
          "int a = 1, b = 2;"
        ],
        "bad": [
          "for (inx = 3 , jnx = 17; inx < X_END; inx ++, jnx ++ ) { mapPoint(inx , jnx); }",
          "int a = 1 , b = 2 ;"
        ]
      },
      "sectionNumber": "3.7.4",
      "businessRules": [
        "Comma Operator 사용 시, 왼쪽에는 공백을 두지 말아야 한다.",
        "Comma Operator 사용 시, 오른쪽에는 한 칸의 공백을 두어야 한다."
      ],
      "astHints": {
        "nodeTypes": [
          "VariableDeclaration",
          "ExpressionStatement"
        ],
        "checkConditions": [
          "VariableDeclaration 내에서 Comma Operator 사용 여부 확인",
          "ExpressionStatement 내에서 Comma Operator 사용 여부 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_7_5",
      "title": "Complete Data References Indexing ( [ ] ) 과 Dot No",
      "category": "code_style",
      "checkType": "regex_with_validation",
      "description": "배열 인덱싱과 점 표기법을 사용할 때, 피연산자와 연산자 사이에 공백이 없어야 합니다. 예: midName[0], test1.samples",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "\\w+\\s*\\[\\s*\\w+\\s*\\]",
          "flags": "g",
          "description": "공백이 포함된 배열 인덱싱 패턴"
        },
        {
          "pattern": "\\w+\\s*\\.\\s*\\w+",
          "flags": "g",
          "description": "공백이 포함된 점 표기법 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "Complete",
        "Data",
        "References",
        "Indexing",
        "Dot",
        "No"
      ],
      "examples": {
        "good": [
          "initial = midName[0];",
          "accum += test1.samples;"
        ],
        "bad": [
          "initial = midName [0];",
          "accum += test1 . samples;"
        ]
      },
      "sectionNumber": "3.7.5",
      "businessRules": [
        "배열 인덱싱과 점 표기법을 사용할 때, 피연산자와 연산자 사이에 공백이 없어야 한다",
        "공백이 포함된 경우는 허용되지 않는다"
      ],
      "astHints": {
        "nodeTypes": [
          "VariableDeclarator",
          "MemberExpression"
        ],
        "checkConditions": [
          "VariableDeclarator의 initializer가 MemberExpression인 경우",
          "MemberExpression의 object와 property 사이에 공백이 있는지 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_7_6",
      "title": "메소드 호출 1) 메소드 이름과 그 뒤의 왼쪽 괄호 사이에는 공백이 없어야 한다 . 2)",
      "category": "code_style",
      "checkType": "regex",
      "description": "메소드 호출 시 메소드 이름과 왼쪽 괄호 사이에는 공백이 없어야 하며, 인자가 없을 때는 괄호 사이에 공백이 없고, 인자가 있을 때는 인자와 괄호 사이에 적어도 하나 이상의 공백이 있어야 하며, 인자 사이에는 쉼표 뒤에 공백이 있어야 한다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "\\w+\\s*\\(\\s*\\)",
          "flags": "g",
          "description": "인자가 없는 메소드 호출의 패턴 (메소드 이름과 괄호 사이에 공백이 없어야 함)"
        },
        {
          "pattern": "\\w+\\s*\\(\\s*[^\\)]+\\s*\\)",
          "flags": "g",
          "description": "인자가 있는 메소드 호출의 패턴 (인자와 괄호 사이에 공백이 있어야 함)"
        },
        {
          "pattern": ",\\s*",
          "flags": "g",
          "description": "쉼표 뒤에 공백이 있어야 하는 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "메소드",
        "호출",
        "1)",
        "이름과",
        "뒤의",
        "왼쪽",
        "괄호",
        "사이에는",
        "공백이",
        "없어야"
      ],
      "examples": {
        "good": [
          "choice = getChoice();",
          "getChoice()",
          "println( \"Enter two floating point values: \" )",
          "System.out.println(\"Enter two floating point values: \");",
          "listMember.setBounds(xPos1, yPos2, xPos1+150, yPos2+250);"
        ],
        "bad": [
          "choice = getChoice ();",
          "System.out.println( \"Enter two floating point values: \" );",
          "listMember.setBounds( xPos1, yPos2, xPos1+150, yPos2+250 );"
        ]
      },
      "sectionNumber": "3.7.6",
      "businessRules": [
        "메소드 이름과 그 뒤의 왼쪽 괄호 사이에는 공백이 없어야 한다.",
        "메소드에 전해지는 인자가 없을 때에는 여는 괄호와 닫는 괄호 사이에 공백이 없어야 한다.",
        "메소드에 전해지는 인자가 있을 때에는 인자와 앞, 뒤의 괄호 사이에 적어도 하나 이상의 공백이 있어야 한다.",
        "메소드에 전달되는 인자는 쉼표 뒤에 적어도 하나의 공백이 있어야 한다."
      ],
      "astHints": {
        "nodeTypes": [
          "MethodInvocation"
        ],
        "checkConditions": [
          "MethodInvocation 노드의 메소드 이름과 왼쪽 괄호 사이에 공백이 없는지 확인",
          "인자가 없는 경우 괄호 사이에 공백이 없는지 확인",
          "인자가 있는 경우 인자와 괄호 사이에 공백이 있는지 확인",
          "인자 사이에 쉼표 뒤에 공백이 있는지 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_7_7",
      "title": "상수 사용 1) 일반적으로 program documentation 을 향상 시키고 향후 수",
      "category": "code_style",
      "checkType": "regex_with_validation",
      "description": "상수는 static final로 선언되어야 하며, 문자열 상수의 경우 의미가 명확하고 읽기 쉬워야 하며 프로그램 실행 중 변경되지 않을 것으로 예상되는 경우에만 사용해야 한다.",
      "severity": "LOW",
      "patterns": [
        {
          "pattern": "^\\s*static\\s+final\\s+.*=.*;$",
          "flags": "gm",
          "description": "static final 변수 선언 패턴"
        }
      ],
      "customValidator": null,
      "keywords": [
        "상수",
        "사용",
        "1)",
        "일반적으로",
        "program",
        "documentation",
        "향상",
        "시키고",
        "향후"
      ],
      "examples": {
        "good": [
          "public static final String MAX_RETRY_COUNT = \"3\";",
          "public static final int DEFAULT_TIMEOUT = 5000;"
        ],
        "bad": [
          "public static final String MAX_RETRY_COUNT = \"3\";",
          "public static final int DEFAULT_TIMEOUT = 5000;"
        ]
      },
      "sectionNumber": "3.7.7",
      "businessRules": [
        "상수는 static final로 선언되어야 한다",
        "문자열 상수는 의미가 명확하고 읽기 쉬워야 한다",
        "상수는 프로그램 실행 중 변경되지 않을 것으로 예상되어야 한다"
      ],
      "astHints": {
        "nodeTypes": [
          "VariableDeclarator"
        ],
        "checkConditions": [
          "VariableDeclarator 노드가 static final로 선언되었는지 확인",
          "상수 이름이 의미 있고 읽기 쉬운지 확인"
        ]
      },
      "contextualChecks": []
    },
    {
      "ruleId": "code_style.3_3_8",
      "title": "기타 1) 하나의 expression 에는 오직 하나의 할당 연산자를 사용한다 . 아래와",
      "category": "code_style",
      "checkType": "static_analysis",
      "description": "하나의 expression에서는 오직 하나의 할당 연산자만 사용해야 하며, 논리 AND 또는 OR 연산자를 2개 이상 사용하는 표현은 피해야 한다. 또한 NOT 연산자는 읽기 어려운 코드를 만들지 않도록 제한적으로 사용해야 한다.",
      "severity": "LOW",
      "patterns": [],
      "customValidator": null,
      "keywords": [
        "기타",
        "1)",
        "하나의",
        "expression",
        "에는",
        "오직",
        "할당",
        "연산자를",
        "사용한다",
        "아래와"
      ],
      "examples": {
        "good": [
          "a = b = 2;",
          "method1()",
          "method2()",
          "int a = 1;",
          "if (x == 1 && y == 2) { }"
        ],
        "bad": [
          "int a = b = 2;",
          "if ((x = method1()) + (y = method2()) == 10) { }",
          "if (x == 1 || y == 2 || z == 3) { }"
        ]
      },
      "sectionNumber": "3.3.8",
      "businessRules": [
        "하나의 expression에는 오직 하나의 할당 연산자만 사용해야 한다.",
        "논리 AND 또는 OR 연산자는 단일 표현에서 2개 이상 사용하지 않는다.",
        "NOT 연산자는 코드를 읽기 어렵게 하지 않도록 제한적으로 사용한다."
      ],
      "astHints": {
        "nodeTypes": [
          "AssignmentExpression",
          "LogicalExpression"
        ],
        "checkConditions": [
          "AssignmentExpression 노드가 하나의 할당 연산자를 포함하는지 확인",
          "LogicalExpression 노드가 AND 또는 OR 연산자를 2개 이상 포함하지 않는지 확인"
        ]
      },
      "contextualChecks": []
    }
  ]
}