[
  {
    "issueId": "JIRA-12345",
    "title": "데이터베이스 커넥션 누수로 인한 서비스 장애",
    "description": "UserService에서 데이터베이스 커넥션을 제대로 닫지 않아 커넥션 풀이 고갈되고, 피크 시간대에 서비스를 사용할 수 없는 문제가 발생했습니다.",
    "problematicCode": "@Service\npublic class UserService {\n    \n    @Autowired\n    private DataSource dataSource;\n    \n    public User createUser(String name, String email) {\n        Connection conn = dataSource.getConnection();\n        String sql = \"INSERT INTO users (name, email) VALUES ('\" + name + \"', '\" + email + \"')\";\n        PreparedStatement stmt = conn.prepareStatement(sql);\n        stmt.executeUpdate();\n        // conn.close() 누락!\n        \n        return findUserByName(name);\n    }\n}",
    "fixedCode": "@Service\n@Transactional\npublic class UserService {\n    \n    @Autowired\n    private DataSource dataSource;\n    \n    public User createUser(String name, String email) {\n        try (Connection conn = dataSource.getConnection()) {\n            String sql = \"INSERT INTO users (name, email) VALUES (?, ?)\";\n            PreparedStatement stmt = conn.prepareStatement(sql);\n            stmt.setString(1, name);\n            stmt.setString(2, email);\n            stmt.executeUpdate();\n            \n            return findUserByName(name);\n        }\n    }\n}",
    "category": "resource_management",
    "severity": "HIGH",
    "occurrenceCount": 15,
    "resolutionTime": "2.5 hours",
    "tags": ["database", "connection", "leak", "resource", "pool"],
    "createdDate": "2024-01-15T09:30:00Z"
  },
  {
    "issueId": "JIRA-23456",
    "title": "검색 기능의 SQL 인젝션 취약점",
    "description": "ProductService의 검색 메소드에서 SQL 쿼리에 문자열 연결을 사용하여 SQL 인젝션 공격에 취약합니다.",
    "problematicCode": "@Service\npublic class ProductService {\n    \n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    \n    public List<Product> searchProducts(String keyword) {\n        String sql = \"SELECT * FROM products WHERE name LIKE '%\" + keyword + \"%' OR description LIKE '%\" + keyword + \"%'\";\n        return jdbcTemplate.query(sql, new ProductRowMapper());\n    }\n    \n    public Product findProductById(String id) {\n        String sql = \"SELECT * FROM products WHERE id = \" + id;\n        return jdbcTemplate.queryForObject(sql, new ProductRowMapper());\n    }\n}",
    "fixedCode": "@Service\npublic class ProductService {\n    \n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    \n    public List<Product> searchProducts(String keyword) {\n        String sql = \"SELECT * FROM products WHERE name LIKE ? OR description LIKE ?\";\n        String searchPattern = \"%\" + keyword + \"%\";\n        return jdbcTemplate.query(sql, new ProductRowMapper(), searchPattern, searchPattern);\n    }\n    \n    public Product findProductById(String id) {\n        String sql = \"SELECT * FROM products WHERE id = ?\";\n        return jdbcTemplate.queryForObject(sql, new ProductRowMapper(), id);\n    }\n}",
    "category": "security_vulnerability",
    "severity": "CRITICAL",
    "occurrenceCount": 8,
    "resolutionTime": "4 hours",
    "tags": ["sql-injection", "security", "query", "vulnerability"],
    "createdDate": "2024-02-03T14:15:00Z"
  },
  {
    "issueId": "JIRA-34567",
    "title": "주문 처리에서 N+1 쿼리 문제",
    "description": "OrderService에서 루프 안에서 여러 번의 데이터베이스 쿼리를 실행하여 높은 부하 시 성능 저하를 일으키고 있습니다.",
    "problematicCode": "@Service\npublic class OrderService {\n    \n    @Autowired\n    private OrderRepository orderRepository;\n    \n    @Autowired\n    private CustomerService customerService;\n    \n    public List<OrderDTO> getOrdersWithCustomers() {\n        List<Order> orders = orderRepository.findAll();\n        List<OrderDTO> result = new ArrayList<>();\n        \n        for (Order order : orders) {\n            OrderDTO dto = new OrderDTO();\n            dto.setOrderId(order.getId());\n            dto.setAmount(order.getAmount());\n            // N+1 문제 발생!\n            Customer customer = customerService.findById(order.getCustomerId());\n            dto.setCustomerName(customer.getName());\n            result.add(dto);\n        }\n        \n        return result;\n    }\n}",
    "fixedCode": "@Service\npublic class OrderService {\n    \n    @Autowired\n    private OrderRepository orderRepository;\n    \n    @Autowired\n    private CustomerService customerService;\n    \n    public List<OrderDTO> getOrdersWithCustomers() {\n        List<Order> orders = orderRepository.findAllWithCustomers();\n        \n        return orders.stream()\n            .map(order -> {\n                OrderDTO dto = new OrderDTO();\n                dto.setOrderId(order.getId());\n                dto.setAmount(order.getAmount());\n                dto.setCustomerName(order.getCustomer().getName());\n                return dto;\n            })\n            .collect(Collectors.toList());\n    }\n}",
    "category": "performance_issue",
    "severity": "HIGH",
    "occurrenceCount": 12,
    "resolutionTime": "3 hours",
    "tags": ["n+1", "query", "performance", "database", "optimization"],
    "createdDate": "2024-02-10T11:45:00Z"
  },
  {
    "issueId": "JIRA-45678",
    "title": "파일 처리 서비스의 메모리 누수",
    "description": "FileProcessor에서 파일 스트림을 제대로 닫지 않아 메모리 누수가 발생하고 결국 OutOfMemoryError가 발생합니다.",
    "problematicCode": "@Service\npublic class FileProcessor {\n    \n    public void processLargeFile(String filePath) throws IOException {\n        FileInputStream fis = new FileInputStream(filePath);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(fis));\n        \n        String line;\n        while ((line = reader.readLine()) != null) {\n            processLine(line);\n            if (shouldStop()) {\n                return; // 스트림이 닫히지 않음!\n            }\n        }\n        \n        reader.close();\n        fis.close();\n    }\n    \n    private void processLine(String line) {\n        // 라인 처리 로직\n    }\n    \n    private boolean shouldStop() {\n        return System.currentTimeMillis() % 1000 == 0;\n    }\n}",
    "fixedCode": "@Service\npublic class FileProcessor {\n    \n    public void processLargeFile(String filePath) throws IOException {\n        try (FileInputStream fis = new FileInputStream(filePath);\n             BufferedReader reader = new BufferedReader(new InputStreamReader(fis))) {\n            \n            String line;\n            while ((line = reader.readLine()) != null) {\n                processLine(line);\n                if (shouldStop()) {\n                    return;\n                }\n            }\n        }\n    }\n    \n    private void processLine(String line) {\n        // 라인 처리 로직\n    }\n    \n    private boolean shouldStop() {\n        return System.currentTimeMillis() % 1000 == 0;\n    }\n}",
    "category": "resource_management",
    "severity": "HIGH",
    "occurrenceCount": 7,
    "resolutionTime": "1.5 hours",
    "tags": ["memory-leak", "file", "stream", "resource", "cleanup"],
    "createdDate": "2024-02-18T16:20:00Z"
  },
  {
    "issueId": "JIRA-56789",
    "title": "결제 처리에서 예외 처리 누락",
    "description": "PaymentService에서 예외를 제대로 처리하지 않아 일관성 없는 결제 상태와 고객 불만이 발생하고 있습니다.",
    "problematicCode": "@Service\npublic class PaymentService {\n    \n    @Autowired\n    private ExternalPaymentGateway paymentGateway;\n    \n    @Autowired\n    private OrderService orderService;\n    \n    public void processPayment(PaymentRequest request) {\n        Order order = orderService.findById(request.getOrderId());\n        order.setStatus(\"PROCESSING\");\n        orderService.save(order);\n        \n        // 예외 처리 없음!\n        PaymentResponse response = paymentGateway.charge(request);\n        \n        order.setStatus(\"PAID\");\n        order.setPaymentId(response.getPaymentId());\n        orderService.save(order);\n        \n        sendConfirmationEmail(order);\n    }\n    \n    private void sendConfirmationEmail(Order order) {\n        // 이메일 발송 로직\n    }\n}",
    "fixedCode": "@Service\npublic class PaymentService {\n    \n    @Autowired\n    private ExternalPaymentGateway paymentGateway;\n    \n    @Autowired\n    private OrderService orderService;\n    \n    @Transactional\n    public void processPayment(PaymentRequest request) {\n        Order order = orderService.findById(request.getOrderId());\n        order.setStatus(\"PROCESSING\");\n        orderService.save(order);\n        \n        try {\n            PaymentResponse response = paymentGateway.charge(request);\n            \n            order.setStatus(\"PAID\");\n            order.setPaymentId(response.getPaymentId());\n            orderService.save(order);\n            \n            sendConfirmationEmail(order);\n            \n        } catch (PaymentGatewayException e) {\n            order.setStatus(\"PAYMENT_FAILED\");\n            order.setErrorMessage(e.getMessage());\n            orderService.save(order);\n            throw new PaymentProcessingException(\"Payment failed for order: \" + order.getId(), e);\n        } catch (Exception e) {\n            order.setStatus(\"ERROR\");\n            orderService.save(order);\n            throw new PaymentProcessingException(\"Unexpected error processing payment\", e);\n        }\n    }\n    \n    private void sendConfirmationEmail(Order order) {\n        // 이메일 발송 로직\n    }\n}",
    "category": "exception_handling",
    "severity": "HIGH",
    "occurrenceCount": 18,
    "resolutionTime": "2 hours",
    "tags": ["exception", "payment", "transaction", "error-handling"],
    "createdDate": "2024-02-25T10:30:00Z"
  },
  {
    "issueId": "JIRA-67890",
    "title": "캐시 구현에서 스레드 안전성 문제",
    "description": "CustomCacheService에서 여러 스레드가 동시에 캐시에 접근할 때 스레드 안전성 문제가 발생합니다.",
    "problematicCode": "@Service\npublic class CustomCacheService {\n    \n    private Map<String, Object> cache = new HashMap<>();\n    private Map<String, Long> timestamps = new HashMap<>();\n    private static final long CACHE_TTL = 300000;\n    \n    public Object get(String key) {\n        if (isExpired(key)) {\n            cache.remove(key);\n            timestamps.remove(key);\n            return null;\n        }\n        return cache.get(key);\n    }\n    \n    public void put(String key, Object value) {\n        cache.put(key, value);\n        timestamps.put(key, System.currentTimeMillis());\n    }\n    \n    private boolean isExpired(String key) {\n        Long timestamp = timestamps.get(key);\n        return timestamp == null || (System.currentTimeMillis() - timestamp) > CACHE_TTL;\n    }\n    \n    public int size() {\n        return cache.size();\n    }\n}",
    "fixedCode": "@Service\npublic class CustomCacheService {\n    \n    private final Map<String, Object> cache = new ConcurrentHashMap<>();\n    private final Map<String, Long> timestamps = new ConcurrentHashMap<>();\n    private static final long CACHE_TTL = 300000;\n    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n    \n    public Object get(String key) {\n        lock.readLock().lock();\n        try {\n            if (isExpired(key)) {\n                lock.readLock().unlock();\n                lock.writeLock().lock();\n                try {\n                    if (isExpired(key)) {\n                        cache.remove(key);\n                        timestamps.remove(key);\n                        return null;\n                    }\n                    return cache.get(key);\n                } finally {\n                    lock.readLock().lock();\n                    lock.writeLock().unlock();\n                }\n            }\n            return cache.get(key);\n        } finally {\n            lock.readLock().unlock();\n        }\n    }\n    \n    public void put(String key, Object value) {\n        lock.writeLock().lock();\n        try {\n            cache.put(key, value);\n            timestamps.put(key, System.currentTimeMillis());\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n    \n    private boolean isExpired(String key) {\n        Long timestamp = timestamps.get(key);\n        return timestamp == null || (System.currentTimeMillis() - timestamp) > CACHE_TTL;\n    }\n    \n    public int size() {\n        lock.readLock().lock();\n        try {\n            return cache.size();\n        } finally {\n            lock.readLock().unlock();\n        }\n    }\n}",
    "category": "concurrency_issue",
    "severity": "MEDIUM",
    "occurrenceCount": 5,
    "resolutionTime": "6 hours",
    "tags": ["thread-safety", "concurrency", "cache", "synchronization"],
    "createdDate": "2024-03-05T13:45:00Z"
  },
  {
    "issueId": "JIRA-78901",
    "title": "컨트롤러에서 프레임워크 어노테이션 오용",
    "description": "WebController에서 프레임워크 어노테이션을 올바르게 사용하지 않아 부적절한 요청 처리와 보안 우회가 발생하고 있습니다.",
    "problematicCode": "public class UserController {\n    \n    private UserService userService;\n    \n    public UserController(UserService userService) {\n        this.userService = userService;\n    }\n    \n    public ResponseEntity<User> getUser(String userId) {\n        User user = userService.findById(userId);\n        return ResponseEntity.ok(user);\n    }\n    \n    public ResponseEntity<List<User>> getAllUsers() {\n        List<User> users = userService.findAll();\n        return ResponseEntity.ok(users);\n    }\n    \n    public ResponseEntity<User> updateUser(String userId, User user) {\n        User updated = userService.update(userId, user);\n        return ResponseEntity.ok(updated);\n    }\n}",
    "fixedCode": "@RestController\n@RequestMapping(\"/api/users\")\n@Validated\npublic class UserController {\n    \n    private final UserService userService;\n    \n    @Autowired\n    public UserController(UserService userService) {\n        this.userService = userService;\n    }\n    \n    @GetMapping(\"/{userId}\")\n    @PreAuthorize(\"hasRole('USER') and (#userId == authentication.name or hasRole('ADMIN'))\")\n    public ResponseEntity<User> getUser(@PathVariable @Valid String userId) {\n        try {\n            User user = userService.findById(userId);\n            return ResponseEntity.ok(user);\n        } catch (UserNotFoundException e) {\n            return ResponseEntity.notFound().build();\n        }\n    }\n    \n    @GetMapping\n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public ResponseEntity<List<User>> getAllUsers() {\n        List<User> users = userService.findAll();\n        return ResponseEntity.ok(users);\n    }\n    \n    @PutMapping(\"/{userId}\")\n    @PreAuthorize(\"hasRole('USER') and (#userId == authentication.name or hasRole('ADMIN'))\")\n    public ResponseEntity<User> updateUser(@PathVariable String userId, @RequestBody @Valid User user) {\n        try {\n            User updated = userService.update(userId, user);\n            return ResponseEntity.ok(updated);\n        } catch (UserNotFoundException e) {\n            return ResponseEntity.notFound().build();\n        } catch (ValidationException e) {\n            return ResponseEntity.badRequest().build();\n        }\n    }\n}",
    "category": "framework_misuse",
    "severity": "MEDIUM",
    "occurrenceCount": 11,
    "resolutionTime": "2.5 hours",
    "tags": ["framework", "annotation", "spring", "security", "validation"],
    "createdDate": "2024-03-12T09:15:00Z"
  },
  {
    "issueId": "JIRA-89012",
    "title": "프레젠테이션 레이어에 비즈니스 로직 혼재",
    "description": "ReportController에 서비스 레이어에 있어야 할 비즈니스 로직이 포함되어 있어 아키텍처 원칙을 위반하고 있습니다.",
    "problematicCode": "@RestController\npublic class ReportController {\n    \n    @Autowired\n    private OrderRepository orderRepository;\n    \n    @Autowired\n    private CustomerRepository customerRepository;\n    \n    @GetMapping(\"/reports/sales\")\n    public ResponseEntity<SalesReport> getSalesReport(@RequestParam String startDate, @RequestParam String endDate) {\n        LocalDate start = LocalDate.parse(startDate);\n        LocalDate end = LocalDate.parse(endDate);\n        \n        List<Order> orders = orderRepository.findByDateRange(start, end);\n        \n        BigDecimal totalRevenue = BigDecimal.ZERO;\n        int totalOrders = orders.size();\n        Map<String, Integer> productCounts = new HashMap<>();\n        \n        for (Order order : orders) {\n            totalRevenue = totalRevenue.add(order.getAmount());\n            for (OrderItem item : order.getItems()) {\n                String productName = item.getProduct().getName();\n                productCounts.put(productName, productCounts.getOrDefault(productName, 0) + item.getQuantity());\n            }\n        }\n        \n        List<Customer> newCustomers = customerRepository.findNewCustomersByDateRange(start, end);\n        \n        SalesReport report = new SalesReport();\n        report.setTotalRevenue(totalRevenue);\n        report.setTotalOrders(totalOrders);\n        report.setProductSales(productCounts);\n        report.setNewCustomers(newCustomers.size());\n        \n        return ResponseEntity.ok(report);\n    }\n}",
    "fixedCode": "@RestController\n@RequestMapping(\"/api/reports\")\npublic class ReportController {\n    \n    @Autowired\n    private ReportService reportService;\n    \n    @GetMapping(\"/sales\")\n    public ResponseEntity<SalesReport> getSalesReport(@RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate, @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {\n        try {\n            SalesReport report = reportService.generateSalesReport(startDate, endDate);\n            return ResponseEntity.ok(report);\n        } catch (InvalidDateRangeException e) {\n            return ResponseEntity.badRequest().build();\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();\n        }\n    }\n}",
    "category": "architecture_violation",
    "severity": "MEDIUM",
    "occurrenceCount": 9,
    "resolutionTime": "4 hours",
    "tags": ["architecture", "separation", "business-logic", "layering"],
    "createdDate": "2024-03-20T15:30:00Z"
  },
  {
    "issueId": "JIRA-90123",
    "title": "비효율적인 컬렉션 사용으로 인한 성능 문제",
    "description": "DataProcessor에서 비효율적인 자료구조와 알고리즘을 사용하여 대용량 데이터셋 처리 시 성능이 저하됩니다.",
    "problematicCode": "@Service\npublic class DataProcessor {\n    \n    public List<ProcessedData> processLargeDataset(List<RawData> rawData) {\n        List<ProcessedData> result = new ArrayList<>();\n        \n        for (RawData raw : rawData) {\n            List<String> categories = new ArrayList<>();\n            categories.add(\"default\");\n            \n            for (ProcessedData existing : result) {\n                if (existing.getId().equals(raw.getId())) {\n                    continue;\n                }\n            }\n            \n            String processedValue = \"\";\n            for (String part : raw.getParts()) {\n                processedValue += part + \"|\";\n            }\n            \n            ProcessedData processed = new ProcessedData();\n            processed.setId(raw.getId());\n            processed.setValue(processedValue);\n            processed.setCategories(categories);\n            \n            result.add(processed);\n        }\n        \n        for (int i = 0; i < result.size() - 1; i++) {\n            for (int j = 0; j < result.size() - i - 1; j++) {\n                if (result.get(j).getId().compareTo(result.get(j + 1).getId()) > 0) {\n                    ProcessedData temp = result.get(j);\n                    result.set(j, result.get(j + 1));\n                    result.set(j + 1, temp);\n                }\n            }\n        }\n        \n        return result;\n    }\n}",
    "fixedCode": "@Service\npublic class DataProcessor {\n    \n    public List<ProcessedData> processLargeDataset(List<RawData> rawData) {\n        Set<String> processedIds = new HashSet<>();\n        List<ProcessedData> result = new ArrayList<>(rawData.size());\n        List<String> defaultCategories = Collections.singletonList(\"default\");\n        \n        for (RawData raw : rawData) {\n            if (!processedIds.add(raw.getId())) {\n                continue;\n            }\n            \n            StringBuilder valueBuilder = new StringBuilder();\n            for (String part : raw.getParts()) {\n                valueBuilder.append(part).append(\"|\");\n            }\n            \n            ProcessedData processed = new ProcessedData();\n            processed.setId(raw.getId());\n            processed.setValue(valueBuilder.toString());\n            processed.setCategories(defaultCategories);\n            \n            result.add(processed);\n        }\n        \n        result.sort(Comparator.comparing(ProcessedData::getId));\n        \n        return result;\n    }\n}",
    "category": "performance_issue",
    "severity": "MEDIUM",
    "occurrenceCount": 6,
    "resolutionTime": "3 hours",
    "tags": ["performance", "collection", "algorithm", "optimization", "data-structure"],
    "createdDate": "2024-03-28T12:00:00Z"
  },
  {
    "issueId": "JIRA-01234",
    "title": "사용자 콘텐츠 표시에서 크로스 사이트 스크립팅 취약점",
    "description": "ContentController에서 사용자가 생성한 콘텐츠를 적절한 이스케이프 처리 없이 표시하여 XSS 취약점이 발생합니다.",
    "problematicCode": "@Controller\npublic class ContentController {\n    \n    @Autowired\n    private ContentService contentService;\n    \n    @GetMapping(\"/content/{id}\")\n    public String showContent(@PathVariable String id, Model model) {\n        Content content = contentService.findById(id);\n        \n        model.addAttribute(\"title\", content.getTitle());\n        model.addAttribute(\"body\", content.getBody());\n        model.addAttribute(\"author\", content.getAuthor());\n        \n        return \"content/show\";\n    }\n    \n    @PostMapping(\"/content/comment\")\n    @ResponseBody\n    public String addComment(@RequestParam String contentId, @RequestParam String comment) {\n        Comment newComment = new Comment();\n        newComment.setContentId(contentId);\n        newComment.setText(comment);\n        contentService.addComment(newComment);\n        \n        return \"<div class='comment'>\" + comment + \"</div>\";\n    }\n    \n    @GetMapping(\"/search\")\n    public String search(@RequestParam String query, Model model) {\n        List<Content> results = contentService.search(query);\n        model.addAttribute(\"results\", results);\n        model.addAttribute(\"query\", query);\n        \n        return \"content/search\";\n    }\n}",
    "fixedCode": "@Controller\npublic class ContentController {\n    \n    @Autowired\n    private ContentService contentService;\n    \n    @GetMapping(\"/content/{id}\")\n    public String showContent(@PathVariable String id, Model model) {\n        Content content = contentService.findById(id);\n        \n        model.addAttribute(\"title\", HtmlUtils.htmlEscape(content.getTitle()));\n        model.addAttribute(\"body\", sanitizeHtml(content.getBody()));\n        model.addAttribute(\"author\", HtmlUtils.htmlEscape(content.getAuthor()));\n        \n        return \"content/show\";\n    }\n    \n    @PostMapping(\"/content/comment\")\n    @ResponseBody\n    public ResponseEntity<String> addComment(@RequestParam String contentId, @RequestParam @Size(max = 1000) String comment) {\n        if (StringUtils.isBlank(comment)) {\n            return ResponseEntity.badRequest().body(\"Comment cannot be empty\");\n        }\n        \n        Comment newComment = new Comment();\n        newComment.setContentId(contentId);\n        newComment.setText(HtmlUtils.htmlEscape(comment));\n        contentService.addComment(newComment);\n        \n        String safeComment = HtmlUtils.htmlEscape(comment);\n        return ResponseEntity.ok(\"<div class='comment'>\" + safeComment + \"</div>\");\n    }\n    \n    @GetMapping(\"/search\")\n    public String search(@RequestParam String query, Model model) {\n        if (query.length() > 100) {\n            query = query.substring(0, 100);\n        }\n        \n        List<Content> results = contentService.search(query);\n        model.addAttribute(\"results\", results);\n        model.addAttribute(\"query\", HtmlUtils.htmlEscape(query));\n        \n        return \"content/search\";\n    }\n    \n    private String sanitizeHtml(String html) {\n        PolicyFactory policy = Sanitizers.FORMATTING.and(Sanitizers.LINKS);\n        return policy.sanitize(html);\n    }\n}",
    "category": "security_vulnerability",
    "severity": "HIGH",
    "occurrenceCount": 4,
    "resolutionTime": "5 hours",
    "tags": ["xss", "security", "html-escape", "sanitization", "user-input"],
    "createdDate": "2024-04-02T08:45:00Z"
  }
]